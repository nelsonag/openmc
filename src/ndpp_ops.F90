module ndpp_ops

  use ace_header,   only: XsListing
  use constants
  use cross_section, only: calculate_xs
  use dict_header,  only: DictCharInt, DICT_NULL
  use error,        only: fatal_error
  use global
  use list_header,  only: ListElemInt
  use material_header, only: Material
  use math,         only: calc_rn
  use ndpp_header,  only: GrpTransfer, Ndpp
  use output,       only: write_message
  use particle_header, only: Particle
  use search
  use string,       only: ends_with, to_lower, starts_with, to_str
  use tally_header, only: TallyResult
  use xml_interface

  implicit none

  contains

!===============================================================================
! NDPP_READ reads information from a pre-processed nuclear data file
! as generated by the NDPP program and initializes the Ndpp object accordingly.
!===============================================================================

  subroutine ndpp_read(this, listing, get_scatt, get_nuscatt, get_chi_t, get_chi_p, &
                       get_chi_d, scatt_order, is_nuc)
    type(Ndpp), intent(inout) :: this ! Ndpp object to initialize
    type(XsListing),  pointer, intent(in) :: listing ! Current NDPP data file
    logical, intent(in) :: get_scatt   ! Whether or not to get scatt data
    logical, intent(in) :: get_nuscatt ! Whether or not to get nuscatt data
    logical, intent(in) :: get_chi_t   ! Whether or not to get total chi data
    logical, intent(in) :: get_chi_p   ! Whether or not to get prompt chi data
    logical, intent(in) :: get_chi_d   ! Whether or not to get delayed chi data
    integer, intent(in) :: scatt_order ! Number of moments requested in tallies
    logical, intent(in) :: is_nuc      ! Is our data a nuc or an sab?

    integer       :: in = UNIT_DATAFILE ! file unit
    integer       :: i                  ! loop index for data records
    integer       :: location           ! location of NDPP table
    integer       :: filetype           ! Ascii, Binary or HDF5 filetype
    logical       :: file_exists        ! does NDPP library exist?
    character(7)  :: readable           ! is NDPP library readable?
    character(10) :: name               ! name of NDPP table
    real(8)       :: kT                 ! temperature of table
    real(8)       :: dkT                ! difference in temperature of table
    integer       :: NG                 ! Number of energy groups in library
    character(MAX_FILE_LEN) :: filename ! path to NDPP data library
    integer       :: mu_bins            ! NUmber of angular points used
    integer       :: scatt_type         ! Type of scattering data, discarded
    integer       :: lib_order          ! Order of scattering data in library
    integer       :: nuscatter          ! Flag as to if nuscatter data is present
    integer       :: chi_present_int    ! Is chi present? (from input)
    logical       :: chi_present        ! Flag as to if chi data is present
    integer       :: gmin, gmax         ! Min and max possible group transfers
    real(8)       :: thin_tol           ! Thinning tolerance used in lib, discarded
    integer       :: NEin, iE           ! Number of incoming energies and the index
    integer       :: NP                 ! Number of precursors groups
    real(8), allocatable    :: energy_bins(:)  ! Energy group structure
    real(8), allocatable :: temp_outgoing(:,:) ! Temporary storage of scatt data

    ! determine path, file type, and location of table
    filename = listing % path
    filetype = listing % filetype
    location = listing % location

    ! Check if NDPP library exists and is readable
    inquire(FILE=filename, EXIST=file_exists, READ=readable)
    if (.not. file_exists) then
      call fatal_error("NDPP library '" // trim(filename) // &
           "' does not exist!")
    elseif (readable(1:3) == 'NO') then
      call fatal_error("NDPP library '" // trim(filename) // &
           "' is not readable! Change file permissions with chmod command.")
    end if

    if (listing % filetype == ASCII) then
      ! =======================================================================
      ! READ NDPP DATA IN ASCII FORMAT

      ! Find location of table
      open(UNIT=in, FILE=filename, STATUS='old', ACTION='read')
      rewind(UNIT=in)
      do i = 1, location - 1
        read(UNIT=in, FMT=*)
      end do

      ! Read the header information to make sure this is the correct file
      read(UNIT=in, FMT='(A20,1PE20.12,I20,A20)') name, kT, NG
      dkT = abs(kT - listing % kT) / kT
      if ((adjustl(trim(name)) /= listing % name) .or. (dkT > 0.001_8)) then
        call fatal_error("NDPP library '" // trim(filename) // &
             "' does not contain the correct data set where expected!")
      end if
      ! Get the energy bins (not checking, will assume from here on out we have
      ! the right data set)
      allocate(energy_bins(NG + 1))
      read(UNIT=in, FMT=*) energy_bins
      ! The next line is scatt_type, lib_order, nuscatter, chi_present
      read(UNIT=in, FMT='(I20,I20,I20,I20)') scatt_type, lib_order, &
           nuscatter, chi_present_int
      ! Convert chi_present_int to a bool
      if (chi_present_int == 1) then
        chi_present = .True.
      else
        chi_present = .False.
      end if

      ! Finally, mu_bins, thin_tol
      read(UNIT=in, FMT='(I20,1PE20.12)') mu_bins, thin_tol

      ! set lib_order to the right number for allocating the outgoing array
      if (scatt_type == SCATT_TYPE_LEGENDRE) lib_order = lib_order + 1

      ! Start with elastic data
      ! Get Ein information

      ! First find our data length
      read(UNIT=in, FMT='(I20)') NEin
      ! Now allocate all that will be filled
      allocate(this % el_Ein(NEin))
      allocate(this % el_Ein_srch(NG + 1))
      allocate(this % el(NEin))

      ! Now read in el_Ein and el_Ein_srch
      read(UNIT=in, FMT=*) this % el_Ein
      read(UNIT=in, FMT=*) this % el_Ein_srch

      ! Get the elastic moments themselves
      ENERGY_LOOP: do iE = 1, NEin
        ! get gmin and gmax
        read(UNIT=in, FMT='(I20,I20)') gmin, gmax

        if ((gmin > 0) .and. (gmax > 0)) then
          ! Then we can allocate the space. Do it to lib_order
          ! since this is the largest order requested in the tallies.
          ! Since we only need to store up to the maximum, we also need to have
          ! an array for reading the file which we can later truncate to fit
          ! in to this % el(iE) % outgoing.
          allocate(temp_outgoing(lib_order, gmin : gmax))

          ! Now we have a space to store the data, get it.
          read(UNIT=in, FMT=*) temp_outgoing
          ! And copy in to this % el
          allocate(this % el(iE) % outgoing(scatt_order, gmin : gmax))
          this % el(iE) % outgoing(:, gmin : gmax) = &
            temp_outgoing(1 : scatt_order, gmin : gmax)
          deallocate(temp_outgoing)
        end if
      end do ENERGY_LOOP

      ! The remainder only apply to nuclides
      ! (inelastic, nu-inelastic and chi data)
      if (is_nuc) then
        read(UNIT=in, FMT='(I20)') NEin
        if (NEin > 0) then
          ! Now allocate all that will be filled
          allocate(this % inel_Ein(NEin))
          allocate(this % inel_Ein_srch(NG + 1))
          allocate(this % inel(NEin))

          ! Now read in inel_Ein, inel_Ein_srch
          read(UNIT=in, FMT=*) this % inel_Ein
          read(UNIT=in, FMT=*) this % inel_Ein_srch

          ! Get the inelastic moments themselves
          do iE = 1, NEin
            ! get gmin and gmax
            read(UNIT=in, FMT='(I20,I20)') gmin, gmax

            if ((gmin > 0) .and. (gmax > 0)) then
              ! Then we can allocate the space. Do it to lib_order
              ! since this is the largest order requested in the tallies.
              ! Since we only need to store up to the maximum, we also need to
              ! have an array for reading the file which we can later truncate
              ! to fit in to this % inel(iE) % outgoing.
              allocate(temp_outgoing(lib_order, gmin : gmax))

              ! Now we have a space to store the data, get it.
              read(UNIT=in, FMT=*) temp_outgoing
              ! And copy in to this % el
              allocate(this % inel(iE) % outgoing(scatt_order, gmin : gmax))
              this % inel(iE) % outgoing(:, gmin : gmax) = &
                   temp_outgoing(1 : scatt_order, gmin : gmax)
              deallocate(temp_outgoing)
            end if
          end do

          ! Get nu-scatter, if needed
          if (nuscatter == 1) then
            allocate(this % nuinel(NEin))
            ENERGY_LOOP_ASCII: do iE = 1, NEin
              ! get gmin and gmax
              read(UNIT=in, FMT='(I20,I20)') gmin, gmax

              if ((gmin > 0) .and. (gmax > 0)) then
                ! Then we can allocate the space. Do it to lib_order
                ! since this is the largest order requested in the tallies.
                ! Since we only need to store up to the maximum, we also need to have
                ! an array for reading the file which we can later truncate to fit
                ! in to this % nuinel(iE) % outgoing.
                allocate(temp_outgoing(lib_order, gmin : gmax))

                ! Now we have a space to store the data, get it.
                read(UNIT=in, FMT=*) temp_outgoing
                allocate(this % nuinel(iE) % outgoing(scatt_order, &
                  gmin : gmax))
                this % nuinel(iE) % outgoing(:, gmin : gmax) = &
                  temp_outgoing(1 : scatt_order, gmin : gmax)
                deallocate(temp_outgoing)
              end if
            end do ENERGY_LOOP_ASCII
          end if
        end if

        ! Get chi(E_{in}) data if provided
        if (chi_present) then
          ! Get Ein grid and number of precursors
          read(UNIT=in, FMT='(I20,I20)') NEin, NP

          ! Allocate data as needed
          allocate(this % chi_Ein(NEin))
          allocate(this % chi(size(energy_bins) - 1, NEin))
          allocate(this % chi_p(size(energy_bins) - 1, NEin))
          allocate(this % chi_d(size(energy_bins) - 1, NP, NEin))

          ! Get Ein Grid
          read(UNIT=in, FMT=*) this % chi_Ein

          ! Get Chi-Total
          read(UNIT=in, FMT=*) this % chi

          ! Get Chi-Prompt
          read(UNIT=in, FMT=*) this % chi_p

          ! Get Chi-Delayed
          read(UNIT=in, FMT=*) this % chi_d
        end if
      end if

      close(UNIT=in)

    else if (listing % filetype == BINARY) then
      ! =======================================================================
      ! READ NDPP DATA IN BINARY FORMAT

      ! Open file
      open(UNIT=in, FILE=filename, STATUS='old', ACTION='read', ACCESS='stream')
      rewind(UNIT=in)
      ! right now binary files dont have the capability to do location /= 1!

      ! Read the header information to make sure this is the correct file
      read(UNIT=in) name, kT, NG
      dkT = abs(kT - listing % kT) / kT
      if ((adjustl(trim(name)) /= listing % name) .or. (dkT > 0.001_8)) then
        call fatal_error("NDPP library '" // trim(filename) // &
             "' does not contain the correct data set where expected!")
      end if
      ! Get the energy bins (not checking, will assume from here on out we have
      ! the right data set), and the other meta information
      allocate(energy_bins(NG + 1))
      read(UNIT=in) energy_bins, scatt_type, lib_order, &
           nuscatter, chi_present_int, mu_bins, thin_tol

      ! Convert chi_present_int to a bool
      if (chi_present_int == 1) then
        chi_present = .True.
      else
        chi_present = .False.
      end if

      ! set lib_order to the right number for allocating the outgoing array
      if (scatt_type == SCATT_TYPE_LEGENDRE) lib_order = lib_order + 1

      ! Get \sigma_{s,g'->g,l}(E_{in}) data
      ! Get elastic Ein information

      ! First find our data length, doesnt depend on nuc or sab
      read(UNIT=in) NEin

      ! Now allocate all that will be filled
      allocate(this % el_Ein(NEin))
      allocate(this % el_Ein_srch(NG + 1))
      allocate(this % el(NEin))

      ! Now read in el_Ein and el_Ein_srch
      read(UNIT=in) this % el_Ein
      read(UNIT=in) this % el_Ein_srch

      ! Now we can get the elastic moments themselves one-by-one due to sparse
      ! storage nature.
      do iE = 1, NEin
        ! get gmin and gmax
        read(UNIT=in) gmin, gmax

        if ((gmin > 0) .and. (gmax > 0)) then
          ! Then we can allocate the space. Do it to lib_order
          ! since this is the largest order requested in the tallies.
          ! Since we only need to store up to the maximum, we also need to have
          ! an array for reading the file which we can later truncate to fit
          ! in to this % el(iE) % outgoing.
          allocate(temp_outgoing(lib_order, gmin : gmax))

          ! Now we have a space to store the data, get it.
          read(UNIT=in) temp_outgoing
          ! And copy in to this % el
          allocate(this % el(iE) % outgoing(scatt_order, gmin : gmax))
          this % el(iE) % outgoing(:, gmin : gmax) = &
               temp_outgoing(1 : scatt_order, gmin : gmax)
          deallocate(temp_outgoing)
        end if
      end do

      ! The remainder only apply to nuclides
      ! (inelastic, nu-inelastic and chi data)
      if (is_nuc) then
        read(UNIT=in) NEin

        if (NEin > 0) then
          ! Now allocate all that will be filled
          allocate(this % inel_Ein(NEin))
          allocate(this % inel_Ein_srch(NG + 1))
          allocate(this % inel(NEin))

          ! Now read in inel_Ein, inel_Ein_srch
          read(UNIT=in) this % inel_Ein
          read(UNIT=in) this % inel_Ein_srch

          ! Get the inelastic moments themselves
          do iE = 1, NEin
            ! get gmin and gmax
            read(UNIT=in) gmin, gmax

            if ((gmin > 0) .and. (gmax > 0)) then
              ! Then we can allocate the space. Do it to lib_order
              ! since this is the largest order requested in the tallies.
              ! Since we only need to store up to the maximum, we also need to
              ! have an array for reading the file which we can later truncate
              ! to fit in to this % inel(iE) % outgoing.
              allocate(temp_outgoing(lib_order, gmin : gmax))

              ! Now we have a space to store the data, get it.
              read(UNIT=in) temp_outgoing
              ! And copy in to this % inel
              allocate(this % inel(iE) % outgoing(scatt_order, gmin : gmax))
              this % inel(iE) % outgoing(:, gmin : gmax) = &
                   temp_outgoing(1 : scatt_order, gmin : gmax)
              deallocate(temp_outgoing)
            end if
          end do

          ! Get nu-scatter, if needed
          if (nuscatter == 1) then
            allocate(this % nuinel(NEin))
            ENERGY_LOOP_BINARY: do iE = 1, NEin
              ! get gmin and gmax
              read(UNIT=in) gmin, gmax

              if ((gmin > 0) .and. (gmax > 0)) then
                ! Then we can allocate the space. Do it to lib_order
                ! since this is the largest order requested in the tallies.
                ! Since we only need to store up to the maximum, we also need to
                ! have an array for reading the file which we can later truncate
                ! to fit in to this % nuinel(iE) % outgoing.
                allocate(temp_outgoing(lib_order, gmin : gmax))

                ! Now we have a space to store the data, get it.
                read(UNIT=in) temp_outgoing
                ! And copy in to this % nuinel
                allocate(this % nuinel(iE) % outgoing(scatt_order, &
                     gmin : gmax))
                this % nuinel(iE) % outgoing(:, gmin : gmax) = &
                     temp_outgoing(1 : scatt_order, gmin : gmax)
                deallocate(temp_outgoing)
              end if
            end do ENERGY_LOOP_BINARY
          end if
        end if

        ! Get chi data, if provided
        if (chi_present) then
          ! Get Ein grid and Number of Precursors
          read(UNIT=in) NEin, NP

          ! Allocate data as needed
          allocate(this % chi_Ein(NEin))
          allocate(this % chi(size(energy_bins) - 1, NEin))
          allocate(this % chi_p(size(energy_bins) - 1, NEin))
          allocate(this % chi_d(size(energy_bins) - 1, NP, NEin))

          ! Get Ein Grid
          read(UNIT=in) this % chi_Ein

          ! Get Chi-Total
          read(UNIT=in) this % chi

          ! Get Chi-Prompt
          read(UNIT=in) this % chi_p

          ! Get Chi-Delayed
          read(UNIT=in) this % chi_p
        end if
      end if

      close(UNIT=in)

    else if (listing % filetype == H5) then
      ! =======================================================================
      ! READ NDPP DATA IN HDF5 FORMAT

      ! NOT YET IMPLEMENTED
      call fatal_error("HDF5 NDPP Filetypes Not Yet Implemented. " // &
                       "Check ndpp_lib.xml for Errors.")

    end if ! No default needed - read_ndpp_xml() already checked filetype

    ! Finally, the above code read in all data since NDPP libs are sequential
    ! access; now we can deallocate what we do not need
    if (is_nuc) then
      if (.not. get_scatt) then
        if (associated(this % inel)) then
          deallocate(this % inel)
        end if
      end if
      if (.not. get_nuscatt) then
        if (associated(this % nuinel)) then
          deallocate(this % nuinel)
        end if
      end if
      if ((.not. get_scatt) .and. (.not. get_nuscatt)) then
        if (associated(this % el_Ein)) then
          deallocate(this % el_Ein)
        end if
        if (associated(this % el_Ein_srch)) then
          deallocate(this % el_Ein_srch)
        end if
        if (associated(this % inel_Ein)) then
          deallocate(this % inel_Ein)
        end if
        if (associated(this % inel_Ein_srch)) then
          deallocate(this % inel_Ein_srch)
        end if
      end if
      if (.not. get_chi_t) then
        if (associated(this % chi)) then
          deallocate(this % chi)
        end if
      end if
      if (.not. get_chi_p) then
        if (associated(this % chi_p)) then
          deallocate(this % chi_p)
        end if
      end if
      if (.not. get_chi_d) then
        if (associated(this % chi_d)) then
          deallocate(this % chi_d)
        end if
      end if
      if ((.not. get_chi_t) .and. (.not. get_chi_p) .and. (.not. get_chi_d)) then
        if (associated(this % chi_Ein)) then
          deallocate(this % chi_Ein)
        end if
      end if
    else ! Do similar for S(a,b) tables, dont need to check inel here
      if ((.not. get_scatt) .and. (.not. get_nuscatt)) then
        if (associated(this % el)) then
          deallocate(this % el)
        end if
        if (associated(this % el_Ein)) then
          deallocate(this % el_Ein)
        end if
        if (associated(this % el_Ein_srch)) then
          deallocate(this % el_Ein_srch)
        end if
      end if
    end if

    this % is_nuc = is_nuc
    this % is_init = .True.
    this % zaid = listing % zaid
    this % kT = listing % kT

  end subroutine ndpp_read

!===============================================================================
! BUILD_MATERIAL_NDPP Combines multiple NDPP Objects from a material in to one.
!===============================================================================

  function build_material_ndpp(this_mat, i_mat, ndpp_nuc, ndpp_sab, order, &
                               groups, bounds, use_nuinel) result(ndpp_mat)

    type(Material), intent(in)          :: this_mat    ! The working material
    integer, intent(in)                 :: i_mat       ! Current Index of materials
    type(Ndpp), allocatable, intent(in) :: ndpp_nuc(:) ! Reference nuclidic data
    type(Ndpp), allocatable, intent(in) :: ndpp_sab(:) ! Reference sab data
    integer, intent(in)                 :: order       ! Scattering moment size
    integer, intent(in)                 :: groups      ! Total # of outgoing groups
    real(8), intent(in)                 :: bounds(:)   ! Group boundaries
    logical, intent(in)                 :: use_nuinel
    type(Ndpp)                          :: ndpp_mat    ! The result of this method

    integer :: i, i_nuc ! Nuclide index
    integer :: i_sabnuc, i_sab ! Sab index
    type(Ndpp) :: ndpp_temp ! Temporary ndpp object used in the building
    real(8):: temp_out(order, groups) ! Scratch Outgoing transfer probabilities
    real(8):: nu_temp_out(order, groups) ! Scratch Outgoing transfer probabilities
    real(8), allocatable :: elEin(:), Ein(:), chiEin(:), tempchiEin(:) ! Combined Incoming E grid
    real(8), allocatable :: tmp_Ein(:), mat_Ein(:) ! Combined Incoming E grid
    logical, allocatable :: has_sab(:) ! Nuclide has_sab data
    integer, allocatable :: sab_loc(:) ! Location in sab table of the data
    real(8), allocatable :: sab_thresh(:)  ! Highest sab data energy value
    integer, allocatable :: sab_ithresh(:) ! Highest sab data energy value index
    integer :: NE, iE
    real(8) :: atom_density  ! atom density of a nuclide
    type(Particle) :: p
    integer :: gin,g         ! in & outgoing energy group index
    real(8) :: norm      ! Interpolation constant, multiplied by sigS (if in TL)
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    real(8) :: sigs_el   ! Elastic x/s
    real(8) :: sigs_inel ! Inelastic x/s
    real(8) :: sigs      ! Total scattering x/s
    logical :: nuscatt_flag
    real(8) :: Ethresh
    logical :: urr_initial

    ! Store urr_ptables_on setting and turn it off so URR is not tainting the
    ! cross sections we use here.
    urr_initial = urr_ptables_on
    urr_ptables_on = .False.

    ! display message
    call write_message("Combining NDPP data for material " // &
         to_str(this_mat % id), 6)

    ! Initialize the ndpp object with what we know off bat.
    ! First, kT will be the same as all the nuclides so just take the first one's
    ! value:
    ndpp_mat % kT = ndpp_nuc(this_mat % nuclide(1)) % zaid
    ! ndpp % zaid has no meaning for this but we can store the material index here
    ndpp_mat % zaid = this_mat % id
    ! is_nuc will be false, since we are not a nuclide
    ndpp_mat % is_nuc = .False.

    ! Go through and create a combined energy grid to store in the inelastic
    ! slot of Ndpp (and nuinel)
    ! Will also do the same operations for chi_Ein at the same time
    allocate(has_sab(this_mat % n_nuclides))
    allocate(sab_loc(this_mat % n_nuclides))
    allocate(sab_thresh(this_mat % n_nuclides))
    allocate(sab_ithresh(this_mat % n_nuclides))
    has_sab = .False.
    sab_loc = 0
    sab_thresh = ZERO
    sab_ithresh = 0

    do i = 1, this_mat % n_nuclides
      i_nuc = this_mat % nuclide(i)

      ! Need to get s(a,b) grid if its needed for i_nuc and use its values
      ! with the nuc values appended at higher energies for elastic
      if (this_mat % n_sab > 0) then
        i_sab = -1
        do i_sabnuc = 1, this_mat % n_sab
          if (i_nuc == &
              this_mat % nuclide(this_mat % i_sab_nuclides(i_sabnuc))) then
            i_sab = this_mat % i_sab_tables(i_sabnuc)
            sab_loc(i) = i_sab
          end if
        end do
        if (i_sab /= -1) then
          has_sab(i) = .True.
          sab_thresh(i) = ndpp_sab(i_sab) % el_Ein(size(ndpp_sab(i_sab) % el_Ein))
          sab_ithresh(i) = binary_search(ndpp_nuc(i_nuc) % el_Ein,&
                                             size(ndpp_nuc(i_nuc) % el_Ein), &
                                             sab_thresh(i))
        ! Otherwise nothing needed since this nuc doesnt have sab data
        end if
      end if

      if (has_sab(i)) then
        ! NE = size(ndpp_sab(i_sab) % el_Ein) + &
        !   size(ndpp_nuc(i_nuc) % el_Ein(sab_ithresh(i):))
        ! allocate(elEin(NE))
        ! elEin(1 : size(ndpp_sab(i_sab) % el_Ein)) = ndpp_sab(i_sab) % el_Ein
        ! elEin(size(ndpp_sab(i_sab) % el_Ein) + 1:) = &
        !      ndpp_nuc(i_nuc) % el_Ein(sab_ithresh(i):)

        ! Simply merge all the sab and nuc grids together
        !!! If we do this as our final way, then we can delete alot of the
        !!! S(a,b) checking code above too!!!
        ! Add in a point just slightly above the last sab
        ! point to help with interpolation on the nuclide grid
        Ethresh = ndpp_sab(i_sab) % el_Ein(size(ndpp_sab(i_sab) % el_Ein)) + 1E-11_8
        call merge(ndpp_sab(i_sab) % el_Ein, (/Ethresh/), Ein)

        ! Now merge the s(a,b) grid with the elastic grid
        call merge(Ein, ndpp_nuc(i_nuc) % el_Ein, elEin)
        deallocate(Ein)

      else
        NE = size(ndpp_nuc(i_nuc) % el_Ein)
        allocate(elEin(NE))
        elEin = ndpp_nuc(i_nuc) % el_Ein
      end if

      ! Now build combined inelastic grid with elastic grid (which is in elEin)
      if (associated(ndpp_nuc(i_nuc) % inel_Ein)) then
        call merge(ndpp_nuc(i_nuc) % inel_Ein, elEin, Ein)
      else
        ! No inelastic grid, (hydrogen), therefore just copy it over
        allocate(Ein(size(elEin)))
        Ein = elEin
      end if
      deallocate(elEin)

      ! Now I need to merge my new Ein with the material grid
      if (i == 1) then
        ! First time through so nothing to merge with
        allocate(tmp_Ein(size(Ein)))
        tmp_Ein = Ein
      else
        ! Not the first rodeo, so merge it.
        allocate(mat_Ein(size(tmp_Ein)))
        mat_Ein = tmp_Ein
        call merge(Ein, mat_Ein, tmp_Ein)
        deallocate(mat_Ein)
      end if

      ! Now do chi
      ! if (this_mat % fissionable) then
      !   if (i == 1) then
      !     ! This is our first time through, but we have nothing to merge with
      !     allocate(chiEin(size(ndpp_nuc(i_nuc) % chi_Ein)))
      !   else
      !     allocate(tempchiEin(size(chiEin)))
      !     tempchiEin = chiEin
      !     call merge(ndpp_nuc(i_nuc) % chi_Ein, tempchiEin, chiEin)
      !     deallocate(tempchiEin)
      !   end if
      ! end if
    end do

    ! Store the energy grid
    NE = size(tmp_Ein)
    allocate(ndpp_mat % inel_Ein(NE))
    ndpp_mat % inel_Ein = tmp_Ein
    deallocate(tmp_Ein)

    ! We have our grids.  Now we have to go through each incoming
    ! energy point and build the outgoing data, wihch will combine
    ! elastic and inelastic scattering data
    allocate(ndpp_mat % inel(NE))
    allocate(ndpp_mat % nuinel(NE))

    do iE = 1, NE - 1
      ! Build a particle so we can calculate the cross sections
      p % material = i_mat
      p % E = ndpp_mat % inel_Ein(iE)

      ! Calculate those xs
      call calculate_xs(p)

      ! Zero out the outgoing data
      temp_out = ZERO
      nu_temp_out = ZERO

      gin = binary_search(bounds, groups + 1, ndpp_mat % inel_Ein(iE))

      ! Now add in the contribution of elastic and inelastic for each
      do i = 1, this_mat % n_nuclides
        i_nuc = this_mat % nuclide(i)
        atom_density = this_mat % atom_density(i)

        ! Get our specific x/s needed
        call calc_scatter_xs(i_nuc, sigs_el, sigs_inel)
        sigs = micro_xs(i_nuc) % total - micro_xs(i_nuc) % absorption

        if (ndpp_mat % inel_Ein(iE) > sab_thresh(i)) then

          nuscatt_flag = .False.
          ! Now combine the elastic and inelastic distributions to one set,
          ! which will be in ndpp_outgoing(thread_id,:,:)
          call generate_ndpp_distrib_pn(ndpp_nuc(i_nuc), nuscatt_flag, gin, &
                                        order - 1, ndpp_mat % inel_Ein(iE), &
                                        sigs_el, sigs_inel, norm, gmin, gmax)
          ! Add this component to our temporary output, temp_out, weighted
          ! by atom_density
          temp_out(:,gmin:gmax) = temp_out(:,gmin:gmax) + atom_density * &
               ndpp_outgoing(thread_id,:,gmin:gmax) * sigs

          nuscatt_flag = .True.
          ! Now combine the elastic and inelastic distributions to one set,
          ! which will be in ndpp_outgoing(thread_id,:,:)
          call generate_ndpp_distrib_pn(ndpp_nuc(i_nuc), nuscatt_flag, gin, &
                                        order - 1, ndpp_mat % inel_Ein(iE), &
                                        sigs_el, sigs_inel, norm, gmin, gmax)

          ! Add this component to our temporary output, temp_out, weighted
          ! by atom_density
          nu_temp_out(:,gmin:gmax) = nu_temp_out(:,gmin:gmax) + atom_density * &
               ndpp_outgoing(thread_id,:,gmin:gmax) * sigs

        else
          ! Do the same as above, but for sab only
          ! (again, b/c assuming no inelastic and sab overlap)
          i_sab = sab_loc(i)

          nuscatt_flag = .False.

          ! Now combine the elastic and inelastic distributions to one set,
          ! which will be in ndpp_outgoing(thread_id,:,:)
          call generate_ndpp_distrib_pn(ndpp_sab(i_sab), nuscatt_flag, gin, &
                                        order - 1, ndpp_mat % inel_Ein(iE), &
                                        sigs_el, sigs_inel, norm, gmin, gmax)

          ! Add this component to our temporary output, temp_out, weighted
          ! by atom_density
          temp_out(:,gmin:gmax) = temp_out(:,gmin:gmax) + atom_density * &
            ndpp_outgoing(thread_id,:,gmin:gmax) * sigs
          nu_temp_out(:,gmin:gmax) = nu_temp_out(:,gmin:gmax) + atom_density * &
               ndpp_outgoing(thread_id,:,gmin:gmax) * sigs

        end if

      end do

      ! Normalize out any non-1 normalized behavior as well (including truncation
      ! and the macro scopic x/s
      norm = sum(temp_out(1,:))
      temp_out = temp_out / norm
      nu_temp_out = nu_temp_out / norm

      ! Finally, find the gmin and gmax bounds of this set so we can compress
      ! the data storage

      ! find gmin by checking the P0 moment
      do gmin = 1, size(temp_out, dim = 2)
        if (temp_out(1, gmin) > ZERO) exit
      end do
      ! find gmax by checking the P0 moment
      do gmax = size(temp_out, dim = 2), 1, -1
        if (temp_out(1, gmax) > ZERO) exit
      end do
      if (gmin > gmax) then ! we have effectively all zeros
        gmin = 1
        gmax = 1
      end if

      allocate(ndpp_mat % inel(iE) % outgoing(order, gmin:gmax))
      ndpp_mat % inel(iE) % outgoing = temp_out(:,gmin:gmax)

      if (use_nuinel) then
        allocate(ndpp_mat % nuinel(iE) % outgoing(order, gmin:gmax))
        ndpp_mat % nuinel(iE) % outgoing = nu_temp_out(:,gmin:gmax)
      end if

    end do

    ! Set last data point to the same as last - 1 data point
    allocate(ndpp_mat % inel(NE) % outgoing(order, gmin:gmax))
    ndpp_mat % inel(NE) % outgoing = ndpp_mat % inel(NE - 1) % outgoing

    if (use_nuinel) then
      allocate(ndpp_mat % nuinel(NE) % outgoing(order, gmin:gmax))
      ndpp_mat % nuinel(NE) % outgoing = ndpp_mat % nuinel(NE - 1) % outgoing
    end if

    !!!TODO: Chi Data

    ! Now we need to set inel_Ein_srch
    allocate(ndpp_mat % inel_Ein_srch(groups + 1))
    ndpp_mat % inel_Ein_srch(1) = 1
    do g = 2, groups
      ndpp_mat % inel_Ein_srch(g) = binary_search(ndpp_mat % inel_Ein, &
                                                  size(ndpp_mat % inel_Ein), &
                                                  bounds(g))
    end do
    ndpp_mat % inel_Ein_srch(groups + 1) = size(ndpp_mat % inel_Ein)

    ! Restore ptables settings
    urr_ptables_on = urr_initial

    ! And now we are officially initialized, lets make it so
    ndpp_mat % is_init = .True.
  end function build_material_ndpp

!===============================================================================
! NDPP_TALLY_NDPP_SCATT_N determines the scattering moments which were
! previously calculated with a pre-processor such as NDPP;
! this can be used for analog and tracklength estimators;
! this method applies to ndpp-scatter-n tally types (including nu-scatter)
!===============================================================================

  subroutine ndpp_tally_scatt_n(this, i_nuclide, gin, score_index, &
                                filter_index, t_order, mult, is_analog, Ein, &
                                results, nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: i_nuclide    ! index into nuclides array
    integer, intent(in) :: gin          ! Incoming group index
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    logical, intent(in) :: is_analog    ! Is this an analog or TL event?
    real(8), intent(in) :: Ein          ! Incoming energy
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in) :: nuscatt         ! Is this for nuscatter?

    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: l         ! tally order index to score
    real(8) :: norm      ! Interpolation constant, multiplied by sigS (if in TL)
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    real(8) :: sigs_el   ! Elastic x/s
    real(8) :: sigs_inel ! Inelastic x/s
    logical :: nuscatt_flag

    if (present(nuscatt)) then
      nuscatt_flag = nuscatt
    else
      nuscatt_flag = .false.
    end if

    l = t_order + 1

    ! First we need to calculate the x/s to use when creating our distribution.
    call calc_scatter_xs(i_nuclide, sigs_el, sigs_inel)

    ! Now combine the elastic and inelastic distributions to one set,
    ! which will be in ndpp_outgoing(thread_id,:,:)
    call generate_ndpp_distrib_n(this, nuscatt_flag, gin, l, Ein, sigs_el, &
                                 sigs_inel, norm, gmin, gmax)

    ! Apply mult to the normalization constant, norm
    norm = norm * mult
    ! Now apply sigS if we are in tracklength mode
    if (.not. is_analog) then
      norm = norm * (micro_xs(i_nuclide) % total - &
        micro_xs(i_nuclide) % absorption)
    end if

    ! Add the combined distribution to our tally
    do g = gmin, gmax
      g_filter = filter_index + g - 1
!$omp atomic
      results(score_index, g_filter) % value = &
        results(score_index, g_filter) % value + &
        ndpp_outgoing(thread_id, l, g) * norm
    end do
  end subroutine ndpp_tally_scatt_n

!===============================================================================
! NDPP_TALLY_NDPP_SCATT_PN determines the scattering moments which were
! previously calculated with a pre-processor such as NDPP;
! this can be used for analog and tracklength estimators;
! this method applies to ndpp-scatter-pn tally types (including nu-scatter)
!===============================================================================

  subroutine ndpp_tally_scatt_pn(this, i_nuclide, gin, score_index, &
                                 filter_index, t_order, mult, is_analog, Ein, &
                                 results, nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: i_nuclide    ! index into nuclides array
    integer, intent(in) :: gin          ! Incoming group index
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    logical, intent(in) :: is_analog    ! Is this an analog or TL event?
    real(8), intent(in) :: Ein          ! Incoming energy
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in) :: nuscatt         ! Is this for nuscatter?

    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: i_score   ! index of score dimension of results
    integer :: l         ! legendre moment index
    real(8) :: norm      ! Interpolation constant, multiplied by sigS (if in TL)
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    real(8) :: sigs_el   ! Elastic x/s
    real(8) :: sigs_inel ! Inelastic x/s
    logical :: nuscatt_flag

    if (present(nuscatt)) then
      nuscatt_flag = nuscatt
    else
      nuscatt_flag = .false.
    end if

    ! First we need to calculate the x/s to use when creating our distribution.
    call calc_scatter_xs(i_nuclide, sigs_el, sigs_inel)

    ! Now combine the elastic and inelastic distributions to one set,
    ! which will be in ndpp_outgoing(thread_id,:,:)
    call generate_ndpp_distrib_pn(this, nuscatt_flag, gin, t_order, Ein, &
                                  sigs_el, sigs_inel, norm, gmin, gmax)

    ! Apply mult to the normalization constant, norm
    norm = norm * mult
    ! Now apply sigS if we are in tracklength mode
    if (.not. is_analog) then
      norm = norm * (micro_xs(i_nuclide) % total - &
        micro_xs(i_nuclide) % absorption)
    end if

    ! Add the combined distribution to our tally
    do g = gmin, gmax
      g_filter = filter_index + g - 1
      do l = 1, t_order + 1
        i_score = score_index + l - 1
!$omp atomic
        results(i_score, g_filter) % value = &
          results(i_score, g_filter) % value + ndpp_outgoing(thread_id, l, g) * norm
      end do
    end do
  end subroutine ndpp_tally_scatt_pn

!===============================================================================
! NDPP_TALLY_NDPP_SCATT_YN determines the scattering moments which were
! previously calculated with a pre-processor such as NDPP;
! this can be used for analog and tracklength estimators;
! this method applies to ndpp-scatter-yn tally types (including nu-scatter)
! which incorporate the angular flux moments.
!===============================================================================

  subroutine ndpp_tally_scatt_yn(this, i_nuclide, gin, score_index, &
                                 filter_index, t_order, mult, is_analog, Ein, &
                                 uvw, results, nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: i_nuclide    ! index into nuclides array
    integer, intent(in) :: gin          ! Incoming group index
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    logical, intent(in) :: is_analog    ! Is this an analog or TL event?
    real(8), intent(in) :: Ein          ! Incoming energy
    real(8), intent(in) :: uvw(3)       ! direction coordinates
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in) :: nuscatt         ! Is this for nuscatter?

    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: i_score   ! index of score dimension of results
    integer :: l         ! legendre moment index
    real(8) :: norm      ! Interpolation constant, multiplied by sigS (if in TL)
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    integer :: num_lm    ! Number of m for this l
    real(8) :: sigs_el   ! Elastic x/s
    real(8) :: sigs_inel ! Inelastic x/s
    logical :: nuscatt_flag

    if (present(nuscatt)) then
      nuscatt_flag = nuscatt
    else
      nuscatt_flag = .false.
    end if

    ! First we need to calculate the x/s to use when creating our distribution.
    call calc_scatter_xs(i_nuclide, sigs_el, sigs_inel)

    ! Now combine the elastic and inelastic distributions to one set,
    ! which will be in ndpp_outgoing(thread_id,:,:)
    call generate_ndpp_distrib_pn(this, nuscatt_flag, gin, t_order, Ein, sigs_el, sigs_inel, &
                                  norm, gmin, gmax)

    ! Apply mult to the normalization constant, norm
    norm = norm * mult
    ! Now apply sigS if we are in tracklength mode
    if (.not. is_analog) then
      norm = norm * (micro_xs(i_nuclide) % total - &
        micro_xs(i_nuclide) % absorption)
    end if

    ! Add the combined distribution to our tally for each order
    do g = gmin, gmax
      g_filter = filter_index + g - 1
      i_score = score_index
      do l = 0, t_order
        num_lm = 2 * l + 1
!$omp critical (ndpp_tally_scatt_yn)
        results(i_score: i_score + num_lm - 1, g_filter) % value = &
          results(i_score: i_score + num_lm - 1, g_filter) % value + &
          ndpp_outgoing(thread_id, l + 1, g) * norm * calc_rn(l, uvw)
!$omp end critical (ndpp_tally_scatt_yn)

        i_score = i_score + num_lm
      end do
    end do
  end subroutine ndpp_tally_scatt_yn

!===============================================================================
! NDPP_TALLY_NDPP_MAT_SCATT_N does the same as NDPP_TALLY_NDPP_SCATT_N, but
! uses the material-wise data instead of nuclidic data.
!===============================================================================

  subroutine ndpp_tally_mat_scatt_n(this, gin, score_index, filter_index, &
                                    t_order, mult, Ein, results, &
                                    nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: gin          ! Incoming group
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    real(8), intent(in) :: Ein          ! Incoming energy
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in) :: nuscatt         ! Is this for nuscatter?

    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: l         ! tally order index to score
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    logical :: nuscatt_flag

    if (present(nuscatt)) then
      nuscatt_flag = nuscatt
    else
      nuscatt_flag = .false.
    end if

    l = t_order + 1

    call generate_ndpp_mat_distrib_n(this, nuscatt_flag, gin, l, Ein, mult, &
                                     gmin, gmax)

    ! Add the combined distribution to our tally
    do g = gmin, gmax
      g_filter = filter_index + g - 1
!$omp atomic
      results(score_index, g_filter) % value = &
        results(score_index, g_filter) % value + &
        ndpp_outgoing(thread_id, l, g)
    end do
  end subroutine ndpp_tally_mat_scatt_n

!===============================================================================
! NDPP_TALLY_NDPP_MAT_SCATT_PN does the same as NDPP_TALLY_NDPP_SCATT_PN, but
! uses the material-wise data instead of nuclidic data.
!===============================================================================

  subroutine ndpp_tally_mat_scatt_pn(this, gin, score_index, filter_index, &
                                     t_order, mult, Ein, results, &
                                     nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: gin          ! Incoming group
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    real(8), intent(in) :: Ein          ! Incoming energy
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in) :: nuscatt         ! Is this for nuscatter?

    integer :: i_score   ! index of score dimension of results
    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: l         ! tally order index to score
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    logical :: nuscatt_flag

    if (present(nuscatt)) then
      nuscatt_flag = nuscatt
    else
      nuscatt_flag = .false.
    end if

    l = t_order + 1

    call generate_ndpp_mat_distrib_pn(this, nuscatt_flag, gin, l, Ein, mult, &
                                      gmin, gmax)

    ! Add the combined distribution to our tally
    do g = gmin, gmax
      g_filter = filter_index + g - 1
      do l = 1, t_order + 1
        i_score = score_index + l - 1
!$omp atomic
        results(i_score, g_filter) % value = &
          results(i_score, g_filter) % value + ndpp_outgoing(thread_id, l, g)
      end do
    end do
  end subroutine ndpp_tally_mat_scatt_pn

!===============================================================================
! NDPP_TALLY_NDPP_MAT_SCATT_YN does the same as NDPP_TALLY_NDPP_SCATT_YN, but
! uses the material-wise data instead of nuclidic data.
!===============================================================================

  subroutine ndpp_tally_mat_scatt_yn(this, gin, score_index, filter_index, &
                                     t_order, mult, Ein, uvw, results, &
                                     nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: gin          ! Incoming group
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    real(8), intent(in) :: Ein          ! Incoming energy
    real(8), intent(in) :: uvw(3)       ! direction coordinates
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in)    :: nuscatt      ! Is this for nuscatter?

    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: l         ! tally order index to score
    integer :: num_lm    ! Number of m for this l
    integer :: i_score   ! index of score dimension of results
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    logical :: nuscatt_flag

    if (present(nuscatt)) then
      nuscatt_flag = nuscatt
    else
      nuscatt_flag = .false.
    end if

    l = t_order + 1

    call generate_ndpp_mat_distrib_pn(this, nuscatt_flag, gin, l, Ein, mult, &
                                      gmin, gmax)

    ! Add the combined distribution to our tally for each order
    do g = gmin, gmax
      g_filter = filter_index + g - 1
      i_score = score_index
      do l = 0, t_order
        num_lm = 2 * l + 1
!$omp critical (ndpp_tally_mat_scatt_yn)
        results(i_score: i_score + num_lm - 1, g_filter) % value = &
          results(i_score: i_score + num_lm - 1, g_filter) % value + &
          ndpp_outgoing(thread_id, l + 1, g) * calc_rn(l, uvw)
!$omp end critical (ndpp_tally_mat_scatt_yn)

        i_score = i_score + num_lm
      end do
    end do
  end subroutine ndpp_tally_mat_scatt_yn

!===============================================================================
! TALLY_NDPP_CHI determines the fission spectra which were
! previously calculated with a pre-processor such as NDPP;
! this can be used for analog and tracklength estimators;
! this method applies to ndpp-scatter-chi tally types
!===============================================================================

  subroutine ndpp_tally_chi(this, i_nuclide, score_index, filter_index, mult, &
                            is_analog, Ein, score_type, results)

    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: i_nuclide    ! index into nuclides array
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    logical, intent(in) :: is_analog    ! Is this an analog or TL event?
    real(8), intent(in) :: Ein          ! Incoming energy
    integer, intent(in) :: score_type   ! Type of Chi score we are using
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage

    integer :: g                         ! outgoing energy group index
    integer :: g_filter                  ! outgoing energy group index
    integer :: i_grid                    ! index on nuclide energy grid
    real(8) :: f                         ! interp factor on nuclide energy grid
    real(8) :: one_f                     ! (ONE - f)
    real(8), pointer, save :: chi_Ein(:) ! Working Ein grid
    real(8), pointer, save :: chi(:,:)   ! Working chi data

!$omp threadprivate(chi_Ein, chi)

    ! Set up pointers
    chi_Ein => this % chi_Ein
    if (score_type == SCORE_NDPP_CHI) then
      chi => this % chi
    else if (score_type == SCORE_NDPP_CHI_P) then
      chi => this % chi_p
    else if (score_type == SCORE_NDPP_CHI_D) then
      call fatal_error("OpenMC does not yet support Delayed Chi Tallying!")
      !chi => this % chi_d
    end if

    ! Find the grid index and interpolant of ndpp scattering data
    if (Ein <= chi_Ein(1)) then
      i_grid = 1
      f = ZERO
    else if (Ein >= chi_Ein(size(chi_Ein))) then
      ! Should never happen as max(ndpp_Ein) is above filter range
      return
    else
      i_grid = binary_search(chi_Ein, size(chi_Ein), Ein)
      f = (Ein - chi_Ein(i_grid)) / &
        (chi_Ein(i_grid + 1) - chi_Ein(i_grid))
    end if

    ! Calculate 1-f, apply mult, and weight by nu-fission for TL
    one_f = (ONE - f) * mult
    f = f * mult
    ! Weight only by nu for analog since the collision estimator process already
    ! is effectively sampling the fission xs
    if (.not. is_analog) then
      f = f * micro_xs(i_nuclide) % nu_fission
      one_f = one_f * micro_xs(i_nuclide) % nu_fission
    end if

    ! Add the contribution from NDPP data (with interpolation)
    do g = 1, ubound(chi, dim=1)
      g_filter = filter_index + g - 1
!$omp atomic
      results(score_index, g_filter) % value = &
        results(score_index, g_filter) % value + &
        chi(g, i_grid) * one_f + &
        chi(g, i_grid + 1) * f
    end do

  end subroutine ndpp_tally_chi

!===============================================================================
! HELPER SUBROUTINES
!===============================================================================

!===============================================================================
! CALC_SCATTER_XS Find the elastic and total inelastic cross-sections at the
! given energy Ein for the nuclide denoted by i_nuclide.
!===============================================================================

  subroutine calc_scatter_xs(i_nuclide, sigs_el, sigs_inel)
    integer, intent(in)  :: i_nuclide ! index into nuclides array
    real(8), intent(out) :: sigs_el   ! Elastic x/s
    real(8), intent(out) :: sigs_inel ! Inelastic x/s

    if (micro_xs(i_nuclide) % use_ptable) then
      ! We have to get the non-URR elastic x/s which is the average value
      sigs_el = (ONE - micro_xs(i_nuclide) % interp_factor) * &
        nuclides(i_nuclide) % elastic(micro_xs(i_nuclide) % index_grid) &
        + micro_xs(i_nuclide) % interp_factor * &
        nuclides(i_nuclide) % elastic(micro_xs(i_nuclide) % index_grid + 1)
      ! First get the total scattering x/s
      sigs_inel = (ONE - micro_xs(i_nuclide) % interp_factor) * &
        (nuclides(i_nuclide) % total(micro_xs(i_nuclide) % index_grid) - &
         nuclides(i_nuclide) % absorption(micro_xs(i_nuclide) % index_grid)) + &
        (micro_xs(i_nuclide) % interp_factor) * &
        (nuclides(i_nuclide) % total(micro_xs(i_nuclide) % index_grid + 1) - &
         nuclides(i_nuclide) % absorption(micro_xs(i_nuclide) % index_grid + 1))
      ! Now take away elastic to get the total inelastic
      sigs_inel = sigs_inel - sigs_el
    else
      sigs_el   = micro_xs(i_nuclide) % elastic
      sigs_inel = micro_xs(i_nuclide) % total - micro_xs(i_nuclide) % absorption - &
        sigs_el
    end if

  end subroutine calc_scatter_xs


!===============================================================================
! FIND_NDPP_INDICES determines the group boundaries of relevant data in both
! the elastic and inelastic NDPP data sets (as passed to it by the el_* and
! inel_*) data.  Since the data is readily available, it also finds the
! interpolation factors el_f and inel_f.
!===============================================================================

  subroutine find_ndpp_indices(this, gin, Ein, el_gmin, el_gmax, &
                               inel, inel_gmin, inel_gmax, gmin, gmax, &
                               el_igrid, inel_igrid, el_f, inel_f)
    type(Ndpp), intent(in) :: this       ! Ndpp data to use
    integer, intent(in)    :: gin        ! Incoming group index
    real(8), intent(in)    :: Ein        ! Incoming energy
    integer, intent(out)   :: el_gmin    ! Elastic min outgoing group
    integer, intent(out)   :: el_gmax    ! Elastic max outgoing group
    type(GrpTransfer), pointer, intent(in) :: inel(:) ! Inelastic data to use
    integer, intent(out)   :: inel_gmin  ! Inelastic min outgoing group
    integer, intent(out)   :: inel_gmax  ! Inelastic max outgoing group
    integer, intent(out)   :: gmin       ! Min outgoing group for both el and inel
    integer, intent(out)   :: gmax       ! Max outgoing group for both el and inel
    real(8), intent(out)   :: el_f       ! Elastic interpolant
    real(8), intent(out)   :: inel_f     ! Inelastic interpolant
    integer, intent(out)   :: el_igrid   ! Elastic data location
    integer, intent(out)   :: inel_igrid ! Inelastic data location

    integer :: srch_lo, srch_hi

    inel_gmin = huge(0)
    inel_gmax = 0

    ! Create distribution for elastic scattering
    ! First perform the binary search to find where our Ein point is
    srch_lo = this % el_Ein_srch(gin)
    srch_hi = this % el_Ein_srch(gin + 1)
    ! Find the grid index and interpolant of ndpp scattering data
    if (Ein <= this % el_Ein(1)) then
      el_igrid = 1
      el_f = ZERO
    else if (Ein >= this % el_Ein(size(this % el_Ein))) then
      el_igrid = size(this % el_Ein) - 1
      el_f = ONE
    else
      el_igrid = binary_search(this % el_Ein(srch_lo: srch_hi), &
                             srch_hi - srch_lo + 1, Ein) + srch_lo - 1
      el_f = log(Ein / this % el_Ein(el_igrid)) / &
        log(this % el_Ein(el_igrid + 1) / this % el_Ein(el_igrid))
    end if

    ! Now find our gmin and gmax terms
    el_gmin = min(lbound(this % el(el_igrid) % outgoing, dim=2), &
                  lbound(this % el(el_igrid + 1) % outgoing, dim=2))
    el_gmax = max(ubound(this % el(el_igrid) % outgoing, dim=2), &
                  ubound(this % el(el_igrid + 1) % outgoing, dim=2))

    ! Now do the same for inelastic, if it is necessary (i.e., if not s(a,b))
    ! We can tell if we are s(a,b) because then the inel* pointers will be null
    if (associated(inel)) then
      if (Ein <= this % inel_Ein(1)) then
        ! Then our point is below the threshold: break this conditional
        ! without changing inel_gmin and inel_gmax
        gmin = el_gmin
        gmax = el_gmax
        if (gmin == huge(0)) then
          gmin = 0
          gmax = -1
        end if
      else
        ! Perform same steps as above, but with inelastic.
        ! Also, we will get our normalization constants from the NDPP data itself.
        ! First perform the binary search to find where our incoming E points is
        srch_lo = this % inel_Ein_srch(gin)
        srch_hi = this % inel_Ein_srch(gin + 1)
        ! Find the grid index and interpolant of ndpp scattering data
        if (Ein >= this % inel_Ein(size(this % inel_Ein))) then
          inel_igrid = size(this % inel_Ein) - 1
          inel_f = ONE
        else
          inel_igrid = binary_search(this % inel_Ein(srch_lo: srch_hi), &
                                 srch_hi - srch_lo + 1, Ein) + srch_lo - 1
          inel_f = log(Ein / this % inel_Ein(inel_igrid)) / &
            log(this % inel_Ein(inel_igrid + 1) / this % inel_Ein(inel_igrid))
        end if

        ! Now find our gmin and gmax terms
        if ((allocated(inel(inel_igrid) % outgoing)) .and. &
            (allocated(inel(inel_igrid + 1) % outgoing))) then
          inel_gmin = min(lbound(inel(inel_igrid) % outgoing, dim=2), &
                          lbound(inel(inel_igrid + 1) % outgoing, dim=2))
          inel_gmax = max(ubound(inel(inel_igrid) % outgoing, dim=2), &
                          ubound(inel(inel_igrid + 1) % outgoing, dim=2))
        else if (allocated(inel(inel_igrid) % outgoing)) then
          inel_gmin = lbound(inel(inel_igrid) % outgoing, dim=2)
          inel_gmax = ubound(inel(inel_igrid) % outgoing, dim=2)
        else if (allocated(inel(inel_igrid + 1) % outgoing)) then
          inel_gmin = lbound(inel(inel_igrid+1) % outgoing, dim=2)
          inel_gmax = ubound(inel(inel_igrid+1) % outgoing, dim=2)
        end if

        ! Set our group boundaries
        gmin = min(el_gmin, inel_gmin)
        gmax = max(el_gmax, inel_gmax)
      end if
    else
      ! Set our other outgoing data
      gmin = el_gmin
      gmax = el_gmax
    end if

    ! Fix up gmin and gmax if need be
    if (gmin == huge(0)) then
      gmin = 0
      gmax = -1
    end if

  end subroutine find_ndpp_indices

!===============================================================================
! GENERATE_NDPP_DISTRIB_N combines the elastic and inelastic portions of the
! NDPP scattering data such that a single number can be readily tallied.
! This includes performing all the interpolation necessary.  The *_N version of
! this function provides this capability for score-ndpp-*scatter-n tallies only.
!===============================================================================

  subroutine generate_ndpp_distrib_n(this, nuscatt, gin, l, Ein, sigs_el, &
                                     sigs_inel, norm, gmin, gmax)
    type(Ndpp), intent(in) :: this      ! Ndpp data to use
    logical, intent(in)    :: nuscatt   ! Is this for nuscatter?
    integer, intent(in)    :: gin       ! Incoming group index
    integer, intent(in)    :: l         ! Legendre order to score up to
    real(8), intent(in)    :: Ein       ! Incoming energy
    real(8), intent(in)    :: sigs_el   ! Elastic x/s
    real(8), intent(in)    :: sigs_inel ! Inelastic x/s
    real(8), intent(inout) :: norm      ! Total normalization
    integer, intent(inout) :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer, intent(inout) :: gmax      ! Maximum group transfer in ndpp_outgoing

    integer :: el_igrid, inel_igrid
    integer :: el_gmin, el_gmax, inel_gmin, inel_gmax, g
    real(8) :: el_f, el_one_f, inel_f, inel_one_f
    type(GrpTransfer), pointer :: inel(:)

    ! Now set our inelastic data to be inelastic or nuinel, depending on type
    ! requested
    if (nuscatt) then
      inel => this % nuinel
    else
      inel => this % inel
    end if

    ! Find where our data is
    call find_ndpp_indices(this, gin, Ein, el_gmin, el_gmax, &
                           inel, inel_gmin, inel_gmax, gmin, gmax, &
                           el_igrid, inel_igrid, el_f, inel_f)

    ! Create our 1-interpolants based on the newly found *el_f values
    el_one_f   = ONE - el_f
    inel_one_f = ONE - inel_f
    norm = ONE / (sigs_el + sigs_inel)

    ! Set up our distribution storage so we can add the components up
    ndpp_outgoing(thread_id, l, gmin: gmax) = ZERO

    ! Now we can interpolate on the elastic data and put it in ndpp_outgoing
    ! Do lower point
    if (allocated(this % el(el_igrid) % outgoing)) then
      el_one_f = el_one_f * sigs_el
      do g = lbound(this % el(el_igrid) % outgoing, dim=2), &
             ubound(this % el(el_igrid) % outgoing, dim=2)
        ndpp_outgoing(thread_id, l, g) = el_one_f * &
          this % el(el_igrid) % outgoing(l, g)
      end do
    end if
    ! Do upper point
    if (allocated(this % el(el_igrid + 1) % outgoing)) then
      el_f = el_f * sigs_el
      do g = lbound(this % el(el_igrid + 1) % outgoing, dim=2), &
             ubound(this % el(el_igrid + 1) % outgoing, dim=2)
        ndpp_outgoing(thread_id, l, g) = &
          ndpp_outgoing(thread_id, l, g) + &
          el_f * this % el(el_igrid + 1) % outgoing(l, g)
      end do
    end if

    ! And do the same for inelastic, if necessary
    if (inel_gmin /= huge(0)) then
      ! Do lower point
      if (allocated(inel(inel_igrid) % outgoing)) then
        do g = lbound(inel(inel_igrid) % outgoing, dim=2), &
               ubound(inel(inel_igrid) % outgoing, dim=2)
          ndpp_outgoing(thread_id, l, g) = ndpp_outgoing(thread_id, l, g) + &
            inel(inel_igrid) % outgoing(l, g) * inel_one_f
        end do
      end if
      ! Do upper point
      if (allocated(inel(inel_igrid + 1) % outgoing)) then
        do g = lbound(inel(inel_igrid + 1) % outgoing, dim=2), &
               ubound(inel(inel_igrid + 1) % outgoing, dim=2)
          ndpp_outgoing(thread_id, l, g) = ndpp_outgoing(thread_id, l, g) + &
            inel(inel_igrid + 1) % outgoing(l, g) * inel_f
        end do
      end if
    end if

  end subroutine generate_ndpp_distrib_n

!===============================================================================
! GENERATE_NDPP_DISTRIB_PN combines the elastic and inelastic portions of the
! NDPP scattering data such that a single number can be readily tallied.
! This includes performing all the interpolation necessary.  The *_PN version of
! this function provides this capability for score-ndpp-*scatter-pn tallies only.
!===============================================================================

  subroutine generate_ndpp_distrib_pn(this, nuscatt, gin, l, Ein, sigs_el, &
                                      sigs_inel, norm, gmin, gmax)
    type(Ndpp), intent(in) :: this      ! Ndpp data to use
    logical, intent(in)    :: nuscatt    ! Is this for nuscatter?
    integer, intent(in)    :: gin       ! Incoming group index
    integer, intent(in)    :: l         ! Legendre order to score up to
    real(8), intent(in)    :: Ein       ! Incoming energy
    real(8), intent(in)    :: sigs_el   ! Elastic x/s
    real(8), intent(in)    :: sigs_inel ! Inelastic x/s
    real(8), intent(inout) :: norm      ! Total normalization
    integer, intent(inout) :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer, intent(inout) :: gmax      ! Maximum group transfer in ndpp_outgoing

    integer :: el_igrid, inel_igrid
    integer :: el_gmin, el_gmax, inel_gmin, inel_gmax, g
    real(8) :: el_f, el_one_f, inel_f, inel_one_f
    type(GrpTransfer), pointer :: inel(:)

    ! Now set our inelastic data to be inelastic or nuinel, depending on type
    ! requested
    if (nuscatt) then
      inel => this % nuinel
    else
      inel => this % inel
    end if

    ! Find where our data is
    call find_ndpp_indices(this, gin, Ein, el_gmin, el_gmax, &
                           inel, inel_gmin, inel_gmax, gmin, gmax, &
                           el_igrid, inel_igrid, el_f, inel_f)

    ! Create our 1-interpolants based on the newly found *el_f values
    el_one_f   = ONE - el_f
    inel_one_f = ONE - inel_f
    norm = ONE / (sigs_el + sigs_inel)

    ! Set up our distribution storage so we can add the components up
    ndpp_outgoing(thread_id, 1: l + 1, gmin: gmax) = ZERO

    ! Now we can interpolate on the elastic data and put it in ndpp_outgoing
    ! Do lower point
    if (allocated(this % el(el_igrid) % outgoing)) then
      el_one_f = el_one_f * sigs_el
      do g = lbound(this % el(el_igrid) % outgoing, dim=2), &
             ubound(this % el(el_igrid) % outgoing, dim=2)
        ndpp_outgoing(thread_id, 1: l + 1, g) = el_one_f * &
          this % el(el_igrid) % outgoing(1: l + 1, g)
      end do
    end if
    ! Do upper point
    if (allocated(this % el(el_igrid + 1) % outgoing)) then
      el_f = el_f * sigs_el
      do g = lbound(this % el(el_igrid + 1) % outgoing, dim=2), &
             ubound(this % el(el_igrid + 1) % outgoing, dim=2)
        ndpp_outgoing(thread_id, 1: l + 1, g) = &
          ndpp_outgoing(thread_id, 1: l + 1, g) + &
          el_f * this % el(el_igrid + 1) % outgoing(1: l + 1, g)
      end do
    end if

    ! And do the same for inelastic, if necessary
    if (inel_gmin /= huge(0)) then
      ! Do lower point
      if (allocated(inel(inel_igrid) % outgoing)) then
        do g = lbound(inel(inel_igrid) % outgoing, dim=2), &
               ubound(inel(inel_igrid) % outgoing, dim=2)
          ndpp_outgoing(thread_id, 1: l + 1, g) = &
            ndpp_outgoing(thread_id, 1: l + 1, g) + &
            inel(inel_igrid) % outgoing(1: l + 1, g) * inel_one_f
        end do
      end if
      ! Do upper point
      if (allocated(inel(inel_igrid + 1) % outgoing)) then
        do g = lbound(inel(inel_igrid + 1) % outgoing, dim=2), &
               ubound(inel(inel_igrid + 1) % outgoing, dim=2)
          ndpp_outgoing(thread_id, 1: l + 1, g) = &
            ndpp_outgoing(thread_id, 1: l + 1, g) + &
            inel(inel_igrid + 1) % outgoing(1: l + 1, g) * inel_f
        end do
      end if
    end if

  end subroutine generate_ndpp_distrib_pn

!===============================================================================
! GENERATE_NDPP_MAT_* do the same as their non-MAT alternatives, but do it for
! the simplified case of a material-specific NDPP data object.
!===============================================================================

  subroutine generate_ndpp_mat_distrib_n(this, nuscatt, gin, l, Ein, norm, &
                                         gmin, gmax)
    type(Ndpp), intent(in) :: this      ! Ndpp data to use
    logical, intent(in)    :: nuscatt   ! Is this for nuscatter?
    integer, intent(in)    :: gin       ! Incoming group index
    integer, intent(in)    :: l         ! Legendre order to score up to
    real(8), intent(in)    :: Ein       ! Incoming energy
    real(8), intent(in) :: norm      ! Total normalization
    integer, intent(inout) :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer, intent(inout) :: gmax      ! Maximum group transfer in ndpp_outgoing

    integer :: srch_lo, srch_hi, g
    integer :: igrid
    real(8) :: f, one_f
    type(GrpTransfer), pointer :: inel(:)

    if (nuscatt) then
      inel => this % nuinel
    else
      inel => this % inel
    end if

    ! Find the location in the energy array
    srch_lo = this % inel_Ein_srch(gin)
    srch_hi = this % inel_Ein_srch(gin + 1)
    ! Find the grid index and interpolant of ndpp scattering data
    if (Ein >= this % inel_Ein(size(this % inel_Ein))) then
      igrid = size(this % inel_Ein) - 1
      f = ONE
    else
      igrid = binary_search(this % inel_Ein(srch_lo: srch_hi), &
                            srch_hi - srch_lo + 1, Ein) + srch_lo - 1
      f = log(Ein / this % inel_Ein(igrid)) / &
          log(this % inel_Ein(igrid + 1) / this % inel_Ein(igrid))
    end if

    one_f = (ONE - f) * norm
    f = f * norm

    ! Now find our gmin and gmax terms
    if ((allocated(inel(igrid) % outgoing)) .and. &
        (allocated(inel(igrid + 1) % outgoing))) then
      gmin = min(lbound(inel(igrid) % outgoing, dim=2), &
                 lbound(inel(igrid + 1) % outgoing, dim=2))
      gmax = max(ubound(inel(igrid) % outgoing, dim=2), &
                 ubound(inel(igrid + 1) % outgoing, dim=2))
    else if (allocated(inel(igrid) % outgoing)) then
      gmin = lbound(inel(igrid) % outgoing, dim=2)
      gmax = ubound(inel(igrid) % outgoing, dim=2)
    else if (allocated(inel(igrid + 1) % outgoing)) then
      gmin = lbound(inel(igrid + 1) % outgoing, dim=2)
      gmax = ubound(inel(igrid + 1) % outgoing, dim=2)
    end if

    ! Set up our distribution storage so we can add the components up
    ndpp_outgoing(thread_id, l, gmin: gmax) = ZERO

    ! Do lower point
    if (allocated(inel(igrid) % outgoing)) then
      do g = lbound(inel(igrid) % outgoing, dim=2), &
             ubound(inel(igrid) % outgoing, dim=2)
        ndpp_outgoing(thread_id, l, g) = ndpp_outgoing(thread_id, l, g) + &
          inel(igrid) % outgoing(l, g) * one_f
      end do
    end if
    ! Do upper point
    if (allocated(inel(igrid + 1) % outgoing)) then
      do g = lbound(inel(igrid + 1) % outgoing, dim=2), &
             ubound(inel(igrid + 1) % outgoing, dim=2)
        ndpp_outgoing(thread_id, l, g) = ndpp_outgoing(thread_id, l, g) + &
          inel(igrid + 1) % outgoing(l, g) * f
      end do
    end if

  end subroutine generate_ndpp_mat_distrib_n


  subroutine generate_ndpp_mat_distrib_pn(this, nuscatt, gin, l, Ein, norm, &
                                          gmin, gmax)
    type(Ndpp), intent(in) :: this      ! Ndpp data to use
    logical, intent(in)    :: nuscatt   ! Is this for nuscatter?
    integer, intent(in)    :: gin       ! Incoming group index
    integer, intent(in)    :: l         ! Legendre order to score up to
    real(8), intent(in)    :: Ein       ! Incoming energy
    real(8), intent(in) :: norm      ! Total normalization
    integer, intent(inout) :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer, intent(inout) :: gmax      ! Maximum group transfer in ndpp_outgoing

    integer :: srch_lo, srch_hi, g
    integer :: igrid
    real(8) :: f, one_f
    type(GrpTransfer), pointer :: inel(:)

    if (nuscatt) then
      inel => this % nuinel
    else
      inel => this % inel
    end if

    ! Find the location in the energy array
    srch_lo = this % inel_Ein_srch(gin)
    srch_hi = this % inel_Ein_srch(gin + 1)
    ! Find the grid index and interpolant of ndpp scattering data
    if (Ein >= this % inel_Ein(size(this % inel_Ein))) then
      igrid = size(this % inel_Ein) - 1
      f = ONE
    else
      igrid = binary_search(this % inel_Ein(srch_lo: srch_hi), &
                            srch_hi - srch_lo + 1, Ein) + srch_lo - 1
      f = log(Ein / this % inel_Ein(igrid)) / &
          log(this % inel_Ein(igrid + 1) / this % inel_Ein(igrid))
    end if

    one_f = (ONE - f) * norm
    f = f * norm

    ! Now find our gmin and gmax terms
    if ((allocated(inel(igrid) % outgoing)) .and. &
        (allocated(inel(igrid + 1) % outgoing))) then
      gmin = min(lbound(inel(igrid) % outgoing, dim=2), &
                 lbound(inel(igrid + 1) % outgoing, dim=2))
      gmax = max(ubound(inel(igrid) % outgoing, dim=2), &
                 ubound(inel(igrid + 1) % outgoing, dim=2))
    else if (allocated(inel(igrid) % outgoing)) then
      gmin = lbound(inel(igrid) % outgoing, dim=2)
      gmax = ubound(inel(igrid) % outgoing, dim=2)
    else if (allocated(inel(igrid + 1) % outgoing)) then
      gmin = lbound(inel(igrid+1) % outgoing, dim=2)
      gmax = ubound(inel(igrid+1) % outgoing, dim=2)
    end if

    ! Set up our distribution storage so we can add the components up
    ndpp_outgoing(thread_id, 1: l, gmin: gmax) = ZERO

    ! Do lower point
    if (allocated(inel(igrid) % outgoing)) then
      do g = lbound(inel(igrid) % outgoing, dim=2), &
             ubound(inel(igrid) % outgoing, dim=2)
        ndpp_outgoing(thread_id, 1: l, g) = &
             ndpp_outgoing(thread_id, 1: l, g) + &
             inel(igrid) % outgoing(1: l, g) * one_f
      end do
    end if
    ! Do upper point
    if (allocated(inel(igrid + 1) % outgoing)) then
      do g = lbound(inel(igrid + 1) % outgoing, dim=2), &
             ubound(inel(igrid + 1) % outgoing, dim=2)
        ndpp_outgoing(thread_id, 1: l, g) = &
             ndpp_outgoing(thread_id, 1: l, g) + &
             inel(igrid + 1) % outgoing(1: l, g) * f
      end do
    end if

  end subroutine generate_ndpp_mat_distrib_pn


!===============================================================================
! MERGE combines two arrays in to one longer array, maintaining the sorted order
!===============================================================================

    subroutine merge(a, b, result)
      real(8), target, intent(in)    :: a(:)
      real(8), target, intent(in)    :: b(:)
      real(8), allocatable, intent(inout) :: result(:)

      real(8), allocatable :: merged(:)
      integer :: ndata1, ndata2, nab
      integer :: idata1, idata2, ires
      logical :: no_exit = .true.
      real(8), pointer :: data1(:), data2(:)

      if (a(size(a)) > b(size(b))) then
        data1 => b
        data2 => a
      else
        data1 => a
        data2 => b
      end if

      ndata1 = size(data1)
      ndata2 = size(data2)
      nab = ndata1 + ndata2
      allocate(merged(nab))

      idata1 = 1
      idata2 = 1
      do ires = 1, nab
        if (idata1 <= ndata1 .and. idata2 <= ndata2) then
          if (data1(idata1) < data2(idata2)) then
            ! take data2 info, unless it is zero
            ! a zero Ein results in zero scattering, which is not a useful
            ! point to interpolate to.  MC codes will extrapolate in this case
            ! from the bottom-two points. This is more desirable than interpolating
            ! between 0 and the next highest Ein.
            ! Even more desirable, perhaps, would be interpolating between
            ! a suitably low, but non-zero Ein, and the next highest Ein
            if (data1(idata1) == 0.0_8) then
              merged(ires) = 1.0E-11_8
            else
              merged(ires) = data1(idata1)
            end if
            idata1 = idata1 + 1
          else if (data1(idata1) == data2(idata2)) then
            ! take data1 info, but increment both
            merged(ires) = data1(idata1)
            idata1 = idata1 + 1
            idata2 = idata2 + 1
          else
            ! take data2 info, unless it is zero
            ! a zero Ein results in zero scattering, which is not a useful
            ! point to interpolate to.  MC codes will extrapolate in this case
            ! from the bottom-two points. This is more desirable than interpolating
            ! between 0 and the next highest Ein.
            ! Even more desirable, perhaps, would be interpolating between
            ! a suitably low, but non-zero Ein, and the next highest Ein
            if (data2(idata2) == 0.0_8) then
              merged(ires) = 1.0E-11_8
            else
              merged(ires) = data2(idata2)
            end if
            idata2 = idata2 + 1
          end if
        else if (idata1 <= ndata1) then
          ! There are more data1 data than data2s
          ! Take an data1 and then stop building array
          merged(ires) = data1(idata1)
          idata1 = idata1 + 1
          no_exit = .false.
          exit
        else if (idata2 <= ndata2) then
          ! There are more data2s than data1 data
          merged(ires) = data2(idata2)
          idata2 = idata2 + 1
        else
          no_exit = .false.
          exit
        end if
      end do

      ! Clear result if it has values (as it will when it gets here)
      if (allocated(result)) then
        deallocate(result)
      end if

      ! Adjust ires
      if ((.not. no_exit) .or. (ires > nab)) then
        ires = ires - 1
      end if

      ! Store our results
      allocate(result(ires))
      result = merged(1: ires)
      ! Clean up
      deallocate(merged)
    end subroutine merge

end module ndpp_ops
