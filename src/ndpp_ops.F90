module ndpp_ops

  use constants
  use cross_section,   only: calculate_xs
  use dict_header,     only: DictCharInt
  use error,           only: fatal_error
  use global
  use list_header,     only: ListElemInt
  use material_header, only: Material
  use math,            only: calc_rn
  use ndpp_header,     only: GroupTransfer, Ndpp
  use nuclide_header,  only: XsListing
  use output,          only: write_message
  use particle_header, only: Particle
  use search
  use string,          only: ends_with, to_lower, starts_with, to_str
  use tally_header,    only: TallyResult
  use xml_interface

  implicit none

  contains

!===============================================================================
! NDPP_READ reads information from a pre-processed nuclear data file
! as generated by the NDPP program and initializes the Ndpp object accordingly.
!===============================================================================

  subroutine ndpp_read(this, listing, get_scatt, get_nuscatt, get_chi_t, get_chi_p, &
                       get_chi_d, scatt_order, is_nuc)
    type(Ndpp), intent(inout) :: this ! Ndpp object to initialize
    type(XsListing),  pointer, intent(in) :: listing ! Current NDPP data file
    logical, intent(in) :: get_scatt   ! Whether or not to get scatt data
    logical, intent(in) :: get_nuscatt ! Whether or not to get nuscatt data
    logical, intent(in) :: get_chi_t   ! Whether or not to get total chi data
    logical, intent(in) :: get_chi_p   ! Whether or not to get prompt chi data
    logical, intent(in) :: get_chi_d   ! Whether or not to get delayed chi data
    integer, intent(in) :: scatt_order ! Number of moments requested in tallies
    logical, intent(in) :: is_nuc      ! Is our data a nuc or an sab?

    integer       :: in          ! file unit
    integer       :: i           ! loop index for data records
    integer       :: location    ! location of NDPP table
    integer       :: filetype    ! Ascii, Binary or HDF5 filetype
    logical       :: file_exists ! does NDPP library exist?
    character(7)  :: readable    ! is NDPP library readable?
    character(10) :: name        ! name of NDPP table
    real(8)       :: kT          ! temperature of table
    real(8)       :: dkT         ! difference in temperature of table
    integer       :: NG          ! Number of energy groups in library
    character(MAX_FILE_LEN) :: filename ! path to NDPP data library
    integer       :: mu_bins         ! NUmber of angular points used
    integer       :: scatt_type      ! Type of scattering data, discarded
    integer       :: lib_order       ! Order of scattering data in library
    integer       :: nuscatter       ! Flag as to if nuscatter data is present
    integer       :: chi_present_int ! Is chi present? (from input)
    logical       :: chi_present     ! Flag as to if chi data is present
    integer       :: gmin, gmax      ! Min and max possible group transfers
    real(8)       :: thin_tol        ! Thinning tolerance used in lib
    integer       :: NEin, iE        ! Number of incoming E and the index
    integer       :: NP              ! Number of precursors groups
    real(8), allocatable    :: energy_bins(:)  ! Energy group structure
    real(8), allocatable :: temp_outgoing(:,:) ! Temporary scatt data storage

    ! determine path, file type, and location of table
    filename = listing % path
    filetype = listing % filetype
    location = listing % location

    ! Check if NDPP library exists and is readable
    inquire(FILE=filename, EXIST=file_exists, READ=readable)
    if (.not. file_exists) then
      call fatal_error("NDPP library '" // trim(filename) // &
           "' does not exist!")
    elseif (readable(1:3) == 'NO') then
      call fatal_error("NDPP library '" // trim(filename) // &
           "' is not readable! Change file permissions with chmod command.")
    end if

    if (listing % filetype == ASCII) then
      ! =======================================================================
      ! READ NDPP DATA IN ASCII FORMAT

      ! Find location of table
      open(NEWUNIT=in, FILE=filename, STATUS='old', ACTION='read')
      rewind(UNIT=in)
      do i = 1, location - 1
        read(UNIT=in, FMT=*)
      end do

      ! Read the header information to make sure this is the correct file
      read(UNIT=in, FMT='(A20,1PE20.12,I20,A20)') name, kT, NG
      dkT = abs(kT - listing % kT) / kT
      if ((adjustl(trim(name)) /= listing % name) .or. (dkT > 0.001_8)) then
        call fatal_error("NDPP library '" // trim(filename) // &
             "' does not contain the correct data set where expected!")
      end if
      ! Get the energy bins (not checking, will assume from here on out we have
      ! the right data set)
      allocate(energy_bins(NG + 1))
      read(UNIT=in, FMT=*) energy_bins
      ! The next line is scatt_type, lib_order, nuscatter, chi_present
      read(UNIT=in, FMT='(I20,I20,I20,I20)') scatt_type, lib_order, &
           nuscatter, chi_present_int
      ! Convert chi_present_int to a bool
      if (chi_present_int == 1) then
        chi_present = .True.
      else
        chi_present = .False.
      end if

      ! Finally, mu_bins, thin_tol
      read(UNIT=in, FMT='(I20,1PE20.12)') mu_bins, thin_tol

      ! set lib_order to the right number for allocating the outgoing array
      if (scatt_type == SCATT_TYPE_LEGENDRE) lib_order = lib_order + 1

      ! Start with elastic data
      ! Get Ein information

      ! First find our data length
      read(UNIT=in, FMT='(I20)') NEin
      ! Now allocate all that will be filled
      allocate(this % el_Ein(NEin))
      allocate(this % el_Ein_srch(NG + 1))
      allocate(this % el(NEin))

      ! Now read in el_Ein and el_Ein_srch
      read(UNIT=in, FMT=*) this % el_Ein
      read(UNIT=in, FMT=*) this % el_Ein_srch

      ! Get the elastic moments themselves
      ENERGY_LOOP: do iE = 1, NEin
        ! get gmin and gmax
        read(UNIT=in, FMT='(I20,I20)') gmin, gmax

        if ((gmin > 0) .and. (gmax > 0)) then
          ! Then we can allocate the space. Do it to lib_order
          ! since this is the largest order requested in the tallies.
          ! Since we only need to store up to the maximum, we also need to have
          ! an array for reading the file which we can later truncate to fit
          ! in to this % el(iE) % outgoing.
          allocate(temp_outgoing(lib_order, gmin : gmax))

          ! Now we have a space to store the data, get it.
          read(UNIT=in, FMT=*) temp_outgoing
          ! And copy in to this % el
          allocate(this % el(iE) % outgoing(scatt_order, gmin : gmax))
          this % el(iE) % outgoing(:, gmin : gmax) = &
               temp_outgoing(1 : scatt_order, gmin : gmax)
          deallocate(temp_outgoing)
        end if
      end do ENERGY_LOOP

      ! The remainder only apply to nuclides
      ! (inelastic, nu-inelastic and chi data)
      if (is_nuc) then
        read(UNIT=in, FMT='(I20)') NEin
        if (NEin > 0) then
          ! Now allocate all that will be filled
          allocate(this % inel_Ein(NEin))
          allocate(this % inel_Ein_srch(NG + 1))
          allocate(this % inel(NEin))

          ! Now read in inel_Ein, inel_Ein_srch
          read(UNIT=in, FMT=*) this % inel_Ein
          read(UNIT=in, FMT=*) this % inel_Ein_srch

          ! Get the inelastic moments themselves
          do iE = 1, NEin
            ! get gmin and gmax
            read(UNIT=in, FMT='(I20,I20)') gmin, gmax

            if ((gmin > 0) .and. (gmax > 0)) then
              ! Then we can allocate the space. Do it to lib_order
              ! since this is the largest order requested in the tallies.
              ! Since we only need to store up to the maximum, we also need to
              ! have an array for reading the file which we can later truncate
              ! to fit in to this % inel(iE) % outgoing.
              allocate(temp_outgoing(lib_order, gmin : gmax))

              ! Now we have a space to store the data, get it.
              read(UNIT=in, FMT=*) temp_outgoing
              ! And copy in to this % el
              allocate(this % inel(iE) % outgoing(scatt_order, gmin : gmax))
              this % inel(iE) % outgoing(:, gmin : gmax) = &
                   temp_outgoing(1 : scatt_order, gmin : gmax)
              deallocate(temp_outgoing)
            end if
          end do

          ! Get nu-scatter, if needed
          if (nuscatter == 1) then
            allocate(this % nuinel(NEin))
            ENERGY_LOOP_ASCII: do iE = 1, NEin
              ! get gmin and gmax
              read(UNIT=in, FMT='(I20,I20)') gmin, gmax

              if ((gmin > 0) .and. (gmax > 0)) then
                ! Then we can allocate the space. Do it to lib_order
                ! since this is the largest order requested in the tallies.
                ! Since we only need to store up to the maximum, we also
                ! need to have an array for reading the file which we can
                ! later truncate to fit in to this % nuinel(iE) % outgoing.
                allocate(temp_outgoing(lib_order, gmin : gmax))

                ! Now we have a space to store the data, get it.
                read(UNIT=in, FMT=*) temp_outgoing
                allocate(this % nuinel(iE) % outgoing(scatt_order, &
                  gmin : gmax))
                this % nuinel(iE) % outgoing(:, gmin : gmax) = &
                  temp_outgoing(1 : scatt_order, gmin : gmax)
                deallocate(temp_outgoing)
              end if
            end do ENERGY_LOOP_ASCII
          end if
        end if

        ! Get chi(E_{in}) data if provided
        if (chi_present) then
          ! Get Ein grid and number of precursors
          read(UNIT=in, FMT='(I20,I20)') NEin, NP

          ! Allocate data as needed
          allocate(this % chi_Ein(NEin))
          allocate(this % chi(size(energy_bins) - 1, NEin))
          allocate(this % chi_p(size(energy_bins) - 1, NEin))
          allocate(this % chi_d(size(energy_bins) - 1, NP, NEin))

          ! Get Ein Grid
          read(UNIT=in, FMT=*) this % chi_Ein

          ! Get Chi-Total
          read(UNIT=in, FMT=*) this % chi

          ! Get Chi-Prompt
          read(UNIT=in, FMT=*) this % chi_p

          ! Get Chi-Delayed
          read(UNIT=in, FMT=*) this % chi_d
        end if
      end if

      close(UNIT=in)

    else if (listing % filetype == BINARY) then
      ! =======================================================================
      ! READ NDPP DATA IN BINARY FORMAT

      ! Open file
      open(UNIT=in, FILE=filename, STATUS='old', ACTION='read', &
           ACCESS='stream')
      rewind(UNIT=in)
      ! right now binary files dont have the capability to do location /= 1!

      ! Read the header information to make sure this is the correct file
      read(UNIT=in) name, kT, NG
      dkT = abs(kT - listing % kT) / kT
      if ((adjustl(trim(name)) /= listing % name) .or. (dkT > 0.001_8)) then
        call fatal_error("NDPP library '" // trim(filename) // &
             "' does not contain the correct data set where expected!")
      end if
      ! Get the energy bins (not checking, will assume from here on out we have
      ! the right data set), and the other meta information
      allocate(energy_bins(NG + 1))
      read(UNIT=in) energy_bins, scatt_type, lib_order, &
           nuscatter, chi_present_int, mu_bins, thin_tol

      ! Convert chi_present_int to a bool
      if (chi_present_int == 1) then
        chi_present = .True.
      else
        chi_present = .False.
      end if

      ! set lib_order to the right number for allocating the outgoing array
      if (scatt_type == SCATT_TYPE_LEGENDRE) lib_order = lib_order + 1

      ! Get \sigma_{s,g'->g,l}(E_{in}) data
      ! Get elastic Ein information

      ! First find our data length, doesnt depend on nuc or sab
      read(UNIT=in) NEin

      ! Now allocate all that will be filled
      allocate(this % el_Ein(NEin))
      allocate(this % el_Ein_srch(NG + 1))
      allocate(this % el(NEin))

      ! Now read in el_Ein and el_Ein_srch
      read(UNIT=in) this % el_Ein
      read(UNIT=in) this % el_Ein_srch

      ! Now we can get the elastic moments themselves one-by-one due to sparse
      ! storage nature.
      do iE = 1, NEin
        ! get gmin and gmax
        read(UNIT=in) gmin, gmax

        if ((gmin > 0) .and. (gmax > 0)) then
          ! Then we can allocate the space. Do it to lib_order
          ! since this is the largest order requested in the tallies.
          ! Since we only need to store up to the maximum, we also need to have
          ! an array for reading the file which we can later truncate to fit
          ! in to this % el(iE) % outgoing.
          allocate(temp_outgoing(lib_order, gmin : gmax))

          ! Now we have a space to store the data, get it.
          read(UNIT=in) temp_outgoing
          ! And copy in to this % el
          allocate(this % el(iE) % outgoing(scatt_order, gmin : gmax))
          this % el(iE) % outgoing(:, gmin : gmax) = &
               temp_outgoing(1 : scatt_order, gmin : gmax)
          deallocate(temp_outgoing)
        end if
      end do

      ! The remainder only apply to nuclides
      ! (inelastic, nu-inelastic and chi data)
      if (is_nuc) then
        read(UNIT=in) NEin

        if (NEin > 0) then
          ! Now allocate all that will be filled
          allocate(this % inel_Ein(NEin))
          allocate(this % inel_Ein_srch(NG + 1))
          allocate(this % inel(NEin))

          ! Now read in inel_Ein, inel_Ein_srch
          read(UNIT=in) this % inel_Ein
          read(UNIT=in) this % inel_Ein_srch

          ! Get the inelastic moments themselves
          do iE = 1, NEin
            ! get gmin and gmax
            read(UNIT=in) gmin, gmax

            if ((gmin > 0) .and. (gmax > 0)) then
              ! Then we can allocate the space. Do it to lib_order
              ! since this is the largest order requested in the tallies.
              ! Since we only need to store up to the maximum, we also need to
              ! have an array for reading the file which we can later truncate
              ! to fit in to this % inel(iE) % outgoing.
              allocate(temp_outgoing(lib_order, gmin : gmax))

              ! Now we have a space to store the data, get it.
              read(UNIT=in) temp_outgoing
              ! And copy in to this % inel
              allocate(this % inel(iE) % outgoing(scatt_order, gmin : gmax))
              this % inel(iE) % outgoing(:, gmin : gmax) = &
                   temp_outgoing(1 : scatt_order, gmin : gmax)
              deallocate(temp_outgoing)
            end if
          end do

          ! Get nu-scatter, if needed
          if (nuscatter == 1) then
            allocate(this % nuinel(NEin))
            ENERGY_LOOP_BINARY: do iE = 1, NEin
              ! get gmin and gmax
              read(UNIT=in) gmin, gmax

              if ((gmin > 0) .and. (gmax > 0)) then
                ! Then we can allocate the space. Do it to lib_order
                ! since this is the largest order requested in the tallies.
                ! Since we only need to store up to the maximum, also need to
                ! have an array for reading file which we later truncate
                ! to fit in to this % nuinel(iE) % outgoing.
                allocate(temp_outgoing(lib_order, gmin : gmax))

                ! Now we have a space to store the data, get it.
                read(UNIT=in) temp_outgoing
                ! And copy in to this % nuinel
                allocate(this % nuinel(iE) % outgoing(scatt_order, &
                     gmin : gmax))
                this % nuinel(iE) % outgoing(:, gmin : gmax) = &
                     temp_outgoing(1 : scatt_order, gmin : gmax)
                deallocate(temp_outgoing)
              end if
            end do ENERGY_LOOP_BINARY
          end if
        end if

        ! Get chi data, if provided
        if (chi_present) then
          ! Get Ein grid and Number of Precursors
          read(UNIT=in) NEin, NP

          ! Allocate data as needed
          allocate(this % chi_Ein(NEin))
          allocate(this % chi(size(energy_bins) - 1, NEin))
          allocate(this % chi_p(size(energy_bins) - 1, NEin))
          allocate(this % chi_d(size(energy_bins) - 1, NP, NEin))

          ! Get Ein Grid
          read(UNIT=in) this % chi_Ein

          ! Get Chi-Total
          read(UNIT=in) this % chi

          ! Get Chi-Prompt
          read(UNIT=in) this % chi_p

          ! Get Chi-Delayed
          read(UNIT=in) this % chi_p
        end if
      end if

      close(UNIT=in)

    end if ! No default needed - read_ndpp_xml() already checked filetype

    ! Finally, the above code read in all data since NDPP libs are sequential
    ! access; now we can deallocate what we do not need
    if (is_nuc) then
      if (.not. get_scatt) then
        if (associated(this % inel)) then
          deallocate(this % inel)
        end if
      end if
      if (.not. get_nuscatt) then
        if (associated(this % nuinel)) then
          deallocate(this % nuinel)
        end if
      end if
      if ((.not. get_scatt) .and. (.not. get_nuscatt)) then
        if (allocated(this % el_Ein)) then
          deallocate(this % el_Ein)
        end if
        if (allocated(this % el_Ein_srch)) then
          deallocate(this % el_Ein_srch)
        end if
        if (associated(this % inel_Ein)) then
          deallocate(this % inel_Ein)
        end if
        if (associated(this % inel_Ein_srch)) then
          deallocate(this % inel_Ein_srch)
        end if
      end if
      if (.not. get_chi_t) then
        if (allocated(this % chi)) then
          deallocate(this % chi)
        end if
      end if
      if (.not. get_chi_p) then
        if (allocated(this % chi_p)) then
          deallocate(this % chi_p)
        end if
      end if
      if (.not. get_chi_d) then
        if (allocated(this % chi_d)) then
          deallocate(this % chi_d)
        end if
      end if
      if ((.not. get_chi_t) .and. (.not. get_chi_p) .and. &
          (.not. get_chi_d)) then
        if (allocated(this % chi_Ein)) then
          deallocate(this % chi_Ein)
        end if
      end if
    else ! Do similar for S(a,b) tables, dont need to check inel here
      if ((.not. get_scatt) .and. (.not. get_nuscatt)) then
        if (allocated(this % el)) then
          deallocate(this % el)
        end if
        if (allocated(this % el_Ein)) then
          deallocate(this % el_Ein)
        end if
        if (allocated(this % el_Ein_srch)) then
          deallocate(this % el_Ein_srch)
        end if
      end if
    end if

    this % is_nuc = is_nuc
    this % is_init = .True.
    this % zaid = listing % zaid
    this % kT = listing % kT

  end subroutine ndpp_read

!===============================================================================
! BUILD_MATERIAL_NDPP Combines multiple NDPP Objects from a material in to one.
!===============================================================================

  function build_material_ndpp(this_mat, i_mat, ndpp_nuc, ndpp_sab, order, &
                               groups, bounds, use_nuinel, tol, &
                               get_macro_s, get_macro_c, &
                               get_chi_t, get_chi_p, get_chi_d) &
                              result(ndpp_mat)

    type(Material), intent(in)          :: this_mat    ! The working material
    integer, intent(in)                 :: i_mat       ! Current Index of materials
    type(Ndpp), allocatable, intent(in) :: ndpp_nuc(:) ! Reference nuclidic data
    type(Ndpp), allocatable, intent(in) :: ndpp_sab(:) ! Reference sab data
    integer, intent(in)                 :: order       ! Scattering moment size
    integer, intent(in)                 :: groups      ! Total # of outgoing groups
    real(8), intent(in)                 :: bounds(:)   ! Group boundaries
    logical, intent(in)                 :: use_nuinel  ! Desire nuinel data?
    real(8), intent(in)                 :: tol         ! Thinning Tolerance
    logical, intent(in)                 :: get_macro_s ! Do this for the scatt data
    logical, intent(in)                 :: get_macro_c ! Do this for the chi data
    logical, intent(in)                 :: get_chi_t   ! get total chi data?
    logical, intent(in)                 :: get_chi_p   ! get prompt chi data?
    logical, intent(in)                 :: get_chi_d   ! get delayed chi data?
    type(Ndpp)                          :: ndpp_mat    ! The result of this method

    integer :: i, i_nuc ! Nuclide index
    integer :: i_sabnuc, i_sab ! Sab index
    real(8):: temp_out(order, groups) ! Scratch Outgoing transfer probabilities
    real(8):: nu_temp_out(order, groups) ! Scratch Outgoing transfer probabilities
    real(8), allocatable :: Ein(:)       ! Combined Nuclidic Incoming E grid
    real(8), allocatable :: tmp_Ein(:), mat_Ein(:) ! Combined Incoming E grid
    logical, allocatable :: has_sab(:) ! Nuclide has_sab data
    integer, allocatable :: sab_loc(:) ! Location in sab table of the data
    integer :: NE, iE
    real(8) :: atom_density  ! atom density of a nuclide
    type(Particle) :: p
    integer :: gin,g         ! in & outgoing energy group index
    real(8) :: norm      ! Interpolation constant, multiplied by sigS (if in TL)
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    real(8) :: sigs_el   ! Elastic x/s
    real(8) :: sigs_inel ! Inelastic x/s
    logical :: nuscatt_flag
    real(8) :: Ethresh
    logical :: urr_initial
    real(8), allocatable :: to_keep(:)
    real(8) :: compression, max_err
    real(8) :: sab_thresh, f, one_f
    integer :: i_grid

    ! Store urr_ptables_on setting and turn it off so URR is not tainting the
    ! cross sections we use here.
    urr_initial = urr_ptables_on
    urr_ptables_on = .False.

    if ((get_macro_s) .or. (get_macro_c)) then

      ! display status message
      call write_message("Combining NDPP Scattering Data for Material " // &
           to_str(this_mat % id), 6)

      ! Initialize the ndpp object with what we know off bat.
      ! First, kT will be the same as all the nuclides so just take the first one's
      ! value:
      ndpp_mat % kT = ndpp_nuc(this_mat % nuclide(1)) % zaid
      ! ndpp % zaid has no meaning for this but we can store the material index here
      ndpp_mat % zaid = this_mat % id
      ! is_nuc will be false, since we are not a nuclide
      ndpp_mat % is_nuc = .False.
    end if

    if (get_macro_s) then
      ! Find which S(a,b) data we need and where
      allocate(has_sab(this_mat % n_nuclides))
      allocate(sab_loc(this_mat % n_nuclides))
      has_sab = .False.
      sab_loc = 0

      do i = 1, this_mat % n_nuclides
        i_nuc = this_mat % nuclide(i)

        ! Need to get s(a,b) grid if its data is needed for this i_nuc
        if (this_mat % n_sab > 0) then
          i_sab = -1
          do i_sabnuc = 1, this_mat % n_sab
            if (i_nuc == &
                this_mat % nuclide(this_mat % i_sab_nuclides(i_sabnuc))) then
              i_sab = this_mat % i_sab_tables(i_sabnuc)
              sab_loc(i) = i_sab
            end if
          end do
          if (i_sab /= -1) then
            has_sab(i) = .True.
          ! Otherwise nothing needed since this nuc doesnt have sab data
          end if
        end if

        ! Begin grid merging:
        ! First take in the nuclide's energy grid as our starting point
        if (bounds(1) <= nuclides(i_nuc) % energy(1)) then
          iE = 1
        else
          iE = binary_search(nuclides(i_nuc) % energy, nuclides(i_nuc) % n_grid, &
                             bounds(1))
        end if
        if (bounds(groups + 1) >= &
            nuclides(i_nuc) % energy(nuclides(i_nuc) % n_grid)) then
          NE = nuclides(i_nuc) % n_grid
        else
          NE = binary_search(nuclides(i_nuc) % energy, nuclides(i_nuc) % n_grid, &
                             bounds(groups + 1))
        end if
        allocate(Ein(NE - iE + 1))
        Ein = nuclides(i_nuc) % energy(iE: NE)

        ! Now, if sab data, add in the relevant ACE and NDPP Ein S(a,b) grids
        if (has_sab(i)) then
          i_sab = sab_loc(i)
          ! First do the ACE
          if (allocated(sab_tables(i_sab) % inelastic_e_in)) then
            call merge_in_place(sab_tables(i_sab) % inelastic_e_in, Ein)
          end if
          if (allocated(sab_tables(i_sab) % elastic_e_in)) then
            call merge_in_place(sab_tables(i_sab) % elastic_e_in, Ein)
          end if
          ! Now the NDPP S(a,b) grid
          ! To do this, will add in a point just slightly above the last sab
          ! point to help with interpolation on the nuclide grid
          Ethresh = ndpp_sab(i_sab) % el_Ein(size(ndpp_sab(i_sab) % el_Ein)) + 1E-11_8
          allocate(tmp_Ein(size(ndpp_sab(i_sab) % el_Ein) + 1))
          tmp_Ein = (/ndpp_sab(i_sab) % el_Ein, Ethresh/)
          ! Now we can add this in
          call merge_in_place(tmp_Ein, Ein)
        end if

        ! Now add in the NDPP elastic grid
        call merge_in_place(ndpp_nuc(i_nuc) % el_Ein, Ein)

        ! And finally, the NDPP inelastic grid (if exists)
        if (associated(ndpp_nuc(i_nuc) % inel_Ein)) then
          call merge_in_place(ndpp_nuc(i_nuc) % inel_Ein, Ein)
        end if

        ! At this point we have a grid for all the data needed for this nuclide
        ! Now we must merge it with what we have so far for the material
        if (i == 1) then
          ! First time through so nothing to merge with
          allocate(mat_Ein(size(Ein)))
          mat_Ein = Ein
        else
          ! Not the first rodeo, so merge it.
          call merge_in_place(Ein, mat_Ein)
        end if
        deallocate(Ein)

      end do

      ! Store the energy grid
      NE = size(mat_Ein)
      allocate(ndpp_mat % inel_Ein(NE))
      ndpp_mat % inel_Ein = mat_Ein
      deallocate(mat_Ein)

      ! We have our grids.  Now we have to go through each incoming
      ! energy point and build the outgoing data, which will combine
      ! elastic and inelastic scattering data
      allocate(ndpp_mat % inel(NE))
      allocate(ndpp_mat % nuinel(NE))

      do iE = 1, NE - 1
        ! Build a particle so we can calculate the cross sections
        p % material = i_mat
        p % E = ndpp_mat % inel_Ein(iE)

        ! Calculate those xs
        call calculate_xs(p)

        ! Zero out the outgoing data
        temp_out = ZERO
        nu_temp_out = ZERO

        gin = binary_search(bounds, groups + 1, ndpp_mat % inel_Ein(iE))

        ! Now add in the contribution of elastic and inelastic for each
        do i = 1, this_mat % n_nuclides
          i_nuc = this_mat % nuclide(i)
          atom_density = this_mat % atom_density(i)

          ! Get our specific x/s needed
          call calc_scatter_xs(i_nuc, sigs_el, sigs_inel)

          if (has_sab(i)) then
            i_sab = sab_loc(i)
            sab_thresh = ndpp_sab(i_sab) % el_Ein(size(ndpp_sab(i_sab) % el_Ein))
          else
            sab_thresh = ZERO
          end if

          if (ndpp_mat % inel_Ein(iE) > sab_thresh) then

            nuscatt_flag = .False.

            ! Now combine the elastic and inelastic distributions to one set,
            ! which will be in ndpp_outgoing(thread_id,:,:)
            call generate_ndpp_distrib_pn(ndpp_nuc(i_nuc), nuscatt_flag, gin, &
                                          order - 1, ndpp_mat % inel_Ein(iE), &
                                          sigs_el, sigs_inel, norm, gmin, gmax)
            ! Add this component to our temporary output, temp_out, weighted
            ! by atom_density
            temp_out(:,gmin:gmax) = temp_out(:,gmin:gmax) + atom_density * &
                 ndpp_outgoing(thread_id,:,gmin:gmax)

            nuscatt_flag = .True.

            ! Now combine the elastic and inelastic distributions to one set,
            ! which will be in ndpp_outgoing(thread_id,:,:)
            call generate_ndpp_distrib_pn(ndpp_nuc(i_nuc), nuscatt_flag, gin, &
                                          order - 1, ndpp_mat % inel_Ein(iE), &
                                          sigs_el, sigs_inel, norm, gmin, gmax)

            ! Add this component to our temporary output, temp_out, weighted
            ! by atom_density
            nu_temp_out(:,gmin:gmax) = nu_temp_out(:,gmin:gmax) + atom_density * &
                 ndpp_outgoing(thread_id,:,gmin:gmax)

          else
            ! Do the same as above, but for sab only
            ! (again, b/c assuming no inelastic and sab overlap)

            nuscatt_flag = .False.

            ! Now combine the elastic and inelastic distributions to one set,
            ! which will be in ndpp_outgoing(thread_id,:,:)
            call generate_ndpp_distrib_pn(ndpp_sab(i_sab), nuscatt_flag, gin, &
                                          order - 1, ndpp_mat % inel_Ein(iE), &
                                          sigs_el, sigs_inel, norm, gmin, gmax)

            ! Add this component to our temporary output, temp_out, weighted
            ! by atom_density
            temp_out(:,gmin:gmax) = temp_out(:,gmin:gmax) + atom_density * &
              ndpp_outgoing(thread_id,:,gmin:gmax)
            nu_temp_out(:,gmin:gmax) = nu_temp_out(:,gmin:gmax) + atom_density * &
                 ndpp_outgoing(thread_id,:,gmin:gmax)

          end if

        end do

        ! Normalize out any non-1 normalized behavior as well (including truncation
        ! and the macro scopic x/s
        norm = sum(temp_out(1,:))
        temp_out = temp_out / norm
        nu_temp_out = nu_temp_out / norm

        allocate(ndpp_mat % inel(iE) % outgoing(order, groups))
        ndpp_mat % inel(iE) % outgoing = temp_out

        if (use_nuinel) then
          allocate(ndpp_mat % nuinel(iE) % outgoing(order, groups))
          ndpp_mat % nuinel(iE) % outgoing = nu_temp_out
        end if

      end do

      ! Set last data point to the same as last - 1 data point
      allocate(ndpp_mat % inel(NE) % outgoing(order, groups))
      ndpp_mat % inel(NE) % outgoing = ndpp_mat % inel(NE - 1) % outgoing

      if (use_nuinel) then
        allocate(ndpp_mat % nuinel(NE) % outgoing(order, groups))
        ndpp_mat % nuinel(NE) % outgoing = ndpp_mat % nuinel(NE - 1) % outgoing
      end if

      ! Perform grid thinning
      if (tol > ZERO) then
        call write_message("  Thinning NDPP data for material " // &
             to_str(this_mat % id), 6)
        allocate(to_keep(groups + 1 + 2))
        to_keep = (/ndpp_mat % inel_Ein(1), bounds(:), &
                   ndpp_mat % inel_Ein(size(ndpp_mat % inel_Ein))/)
        call thin_grid(ndpp_mat % inel_Ein, ndpp_mat % inel, ndpp_mat % nuinel, &
                       to_keep, tol, compression, max_err)
        call write_message("  Completed Thinning, Reduced Storage By " // &
                           trim(to_str(100.0_8 * compression)) // "%", 6)
        call write_message("  Maximum Thinning Error Was " // &
                           trim(to_str(100.0_8 * max_err)) // "%", 6)
      end if

      ! Now that we have thinned we can remove the zero entries from outgoing
      NE = size(ndpp_mat % inel_Ein)
      do iE = 1, NE
        ! find gmin by checking the P0 moment
        do gmin = 1, size(ndpp_mat % inel(iE) % outgoing, dim = 2)
          if (ndpp_mat % inel(iE) % outgoing(1, gmin) > ZERO) exit
        end do
        ! find gmax by checking the P0 moment
        do gmax = size(ndpp_mat % inel(iE) % outgoing, dim = 2), 1, -1
          if (ndpp_mat % inel(iE) % outgoing(1, gmax) > ZERO) exit
        end do
        if (gmin > gmax) then ! we have effectively all zeros
          gmin = 1
          gmax = 1
        end if

        temp_out = ndpp_mat % inel(iE) % outgoing
        nu_temp_out = ndpp_mat % nuinel(iE) % outgoing
        deallocate(ndpp_mat % inel(iE) % outgoing)
        allocate(ndpp_mat % inel(iE) % outgoing(order, gmin:gmax))
        ndpp_mat % inel(iE) % outgoing = temp_out(:, gmin:gmax)
        if (use_nuinel) then
          deallocate(ndpp_mat % nuinel(iE) % outgoing)
          allocate(ndpp_mat % nuinel(iE) % outgoing(order, gmin:gmax))
          ndpp_mat % nuinel(iE) % outgoing = nu_temp_out(:, gmin:gmax)
        end if
      end do

      ! Now we need to set inel_Ein_srch
      allocate(ndpp_mat % inel_Ein_srch(groups + 1))
      ndpp_mat % inel_Ein_srch(1) = 1
      do g = 2, groups
        ndpp_mat % inel_Ein_srch(g) = binary_search(ndpp_mat % inel_Ein, &
                                                    size(ndpp_mat % inel_Ein), &
                                                    bounds(g))
      end do
      ndpp_mat % inel_Ein_srch(groups + 1) = size(ndpp_mat % inel_Ein)
    end if

    if (get_macro_c .and. this_mat % fissionable) then
      do i = 1, this_mat % n_nuclides
        i_nuc = this_mat % nuclide(i)
        if (allocated(ndpp_nuc(i_nuc) % chi_Ein) .and. &
            (nuclides(i_nuc) % fissionable)) then

          ! Begin grid merging
          ! First take in the nuclide's energy grid as our starting point
          if (bounds(1) <= nuclides(i_nuc) % energy(1)) then
            iE = 1
          else
            iE = binary_search(nuclides(i_nuc) % energy, nuclides(i_nuc) % n_grid, &
                               bounds(1))
          end if
          if (bounds(groups + 1) >= &
              nuclides(i_nuc) % energy(nuclides(i_nuc) % n_grid)) then
            NE = nuclides(i_nuc) % n_grid
          else
            NE = binary_search(nuclides(i_nuc) % energy, nuclides(i_nuc) % n_grid, &
                               bounds(groups + 1))
          end if
          allocate(Ein(NE - iE + 1))
          Ein = nuclides(i_nuc) % energy(iE: NE)

          ! Now add in the NDPP chi grid
          call merge_in_place(ndpp_nuc(i_nuc) % chi_Ein, Ein)

          ! At this point we have a grid for all the data needed for this nuclide
          ! Now we must merge it with what we have so far for the material
          if (i == 1) then
            ! First time through so nothing to merge with
            allocate(mat_Ein(size(Ein)))
            mat_Ein = Ein
          else
            ! Not the first rodeo, so merge it.
            call merge_in_place(Ein, mat_Ein)
          end if
          deallocate(Ein)
        end if

      end do

      ! Store the energy grid
      NE = size(mat_Ein)
      allocate(ndpp_mat % chi_Ein(NE))
      ndpp_mat % chi_Ein = mat_Ein
      deallocate(mat_Ein)

      ! We have our grids.  Now we have to go through each incoming
      ! energy point and build the outgoing data.
      ! Will do this for total, prompt, then delayed
      if (get_chi_t) then
        allocate(ndpp_mat % chi(groups,NE))
        ndpp_mat % chi = ZERO
      end if
      if (get_chi_p) then
        allocate(ndpp_mat % chi_p(groups,NE))
        ndpp_mat % chi_p = ZERO
      end if
      ! if (get_chi_d) then
      !   allocate(ndpp_mat % chi_d(groups,NE)) !!! Need to have a way to get NP
      !   ndpp_mat % chi_d = ZERO
      ! end if

      do iE = 1, NE - 1
        ! Build a particle so we can calculate the cross sections
        p % material = i_mat
        p % E = ndpp_mat % chi_Ein(iE)

        ! Calculate those xs
        call calculate_xs(p)

        ! Step through each nuclide and add up the contribution
        do i = 1, this_mat % n_nuclides
          i_nuc = this_mat % nuclide(i)
          atom_density = this_mat % atom_density(i)

          if (allocated(ndpp_nuc(i_nuc) % chi_Ein) .and. &
              (nuclides(i_nuc) % fissionable)) then

            ! Find the grid index and interpolant of ndpp scattering data
            if (p % E <= ndpp_nuc(i_nuc) % chi_Ein(1)) then
              i_grid = 1
              f = ZERO
              one_f = ONE
            else
              i_grid = binary_search(ndpp_nuc(i_nuc) % chi_Ein, &
                                     size(ndpp_nuc(i_nuc) % chi_Ein), p % E)
              f = (p % E - ndpp_nuc(i_nuc) % chi_Ein(i_grid)) / &
                (ndpp_nuc(i_nuc) % chi_Ein(i_grid + 1) - &
                 ndpp_nuc(i_nuc) % chi_Ein(i_grid))
              one_f = ONE - f
            end if

            ! Calculate 1-f, and apply weighting
            f = f * micro_xs(i_nuc) % nu_fission * atom_density
            one_f = one_f * micro_xs(i_nuc) % nu_fission * atom_density

            if (get_chi_t) then
              ndpp_mat % chi(:, iE) = ndpp_mat % chi(:, iE) + &
                   ndpp_nuc(i_nuc) % chi(:, i_grid) * one_f + &
                   ndpp_nuc(i_nuc) % chi(:, i_grid + 1) * f
            end if
            if (get_chi_p) then
              ndpp_mat % chi_p(:, iE) = ndpp_mat % chi_p(:, iE) + &
                   ndpp_nuc(i_nuc) % chi_p(:, i_grid) * one_f + &
                   ndpp_nuc(i_nuc) % chi_p(:, i_grid + 1) * f
            end if
            ! if (get_chi_d) then
            !   ndpp_mat % chi_d(:, iE) = ndpp_mat % chi_d(:, iE) + &
            !        ndpp_nuc(i_nuc) % chi_d(:, i_grid) * one_f + &
            !        ndpp_nuc(i_nuc) % chi_d(:, i_grid + 1) * f
            ! end if
          end if
        end do


        !!!TODO: Thin the chi grid and also write code to apply user thinning
        !!!      to any NDPP grid, regardless of if it is macro or nuclide data

        ! Now normalize the chi values
        if (get_chi_t) then
          norm = sum(ndpp_mat % chi(:,iE))
          if (norm > ZERO) then
            ndpp_mat % chi(:,iE) = ndpp_mat % chi(:,iE) / norm
          end if
        end if
        if (get_chi_p) then
          norm = sum(ndpp_mat % chi_p(:,iE))
          if (norm > ZERO) then
            ndpp_mat % chi_p(:,iE) = ndpp_mat % chi_p(:,iE) / norm
          end if
        end if
        ! if (get_chi_d) then
        !   norm = sum(ndpp_mat % chi_d(:,iE))
        !   if (norm > ZERO) then
        !     ndpp_mat % chi_d(:,iE) = ndpp_mat % chi_d(:,iE) / norm
        !   end if
        ! end if


        ! Set last data point to the same as last - 1 data point
        if (get_chi_t) &
          ndpp_mat % chi(:,NE) = ndpp_mat % chi(:,NE - 1)
        if (get_chi_p) &
          ndpp_mat % chi_p(:,NE) = ndpp_mat % chi_p(:,NE - 1)
        ! if (get_chi_d) &
        !   ndpp_mat % chi_d(:,NE) = ndpp_mat % chi_d(:,NE - 1)

      end do
    end if

    ! Restore ptables settings
    urr_ptables_on = urr_initial

    ! And now we are officially initialized, lets make it so
    ndpp_mat % is_init = .True.
  end function build_material_ndpp

!===============================================================================
! NDPP_TALLY_NDPP_SCATT_N determines the scattering moments which were
! previously calculated with a pre-processor such as NDPP;
! this can be used for analog and tracklength estimators;
! this method applies to ndpp-scatter-n tally types (including nu-scatter)
!===============================================================================

  subroutine ndpp_tally_scatt_n(this, i_nuclide, gin, score_index, &
                                filter_index, t_order, mult, is_analog, Ein, &
                                results, nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: i_nuclide    ! index into nuclides array
    integer, intent(in) :: gin          ! Incoming group index
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (Ein filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    logical, intent(in) :: is_analog    ! Is this an analog or TL event?
    real(8), intent(in) :: Ein          ! Incoming energy
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in) :: nuscatt         ! Is this for nuscatter?

    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: l         ! tally order index to score
    real(8) :: norm      ! Interpolation constant multiplied by sigS (if TL)
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    real(8) :: sigs_el   ! Elastic x/s
    real(8) :: sigs_inel ! Inelastic x/s
    logical :: nuscatt_flag

    if (present(nuscatt)) then
      nuscatt_flag = nuscatt
    else
      nuscatt_flag = .false.
    end if

    l = t_order + 1

    ! First we need to calculate the x/s to use when creating our distribution.
    call calc_scatter_xs(i_nuclide, sigs_el, sigs_inel)

    ! Now combine the elastic and inelastic distributions to one set,
    ! which will be in ndpp_outgoing(thread_id,:,:)
    call generate_ndpp_distrib_n(this, nuscatt_flag, gin, l, Ein, sigs_el, &
                                 sigs_inel, norm, gmin, gmax)

    ! Apply mult to the normalization constant, norm
    norm = norm * mult
    ! Now apply sigS if we are in tracklength mode
    if (.not. is_analog) then
      norm = norm * (micro_xs(i_nuclide) % total - &
           micro_xs(i_nuclide) % absorption)
    end if

    ! Add the combined distribution to our tally
    do g = gmin, gmax
      g_filter = filter_index + g - 1
!$omp atomic
      results(score_index, g_filter) % value = &
          results(score_index, g_filter) % value + &
          ndpp_outgoing(thread_id, l, g) * norm
    end do
  end subroutine ndpp_tally_scatt_n

!===============================================================================
! NDPP_TALLY_NDPP_SCATT_PN determines the scattering moments which were
! previously calculated with a pre-processor such as NDPP;
! this can be used for analog and tracklength estimators;
! this method applies to ndpp-scatter-pn tally types (including nu-scatter)
!===============================================================================

  subroutine ndpp_tally_scatt_pn(this, i_nuclide, gin, score_index, &
                                 filter_index, t_order, mult, is_analog, Ein, &
                                 results, nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: i_nuclide    ! index into nuclides array
    integer, intent(in) :: gin          ! Incoming group index
    integer, intent(in) :: score_index  ! dim=1 starting index in results
    integer, intent(in) :: filter_index ! dim=2 starting index (Ein filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    logical, intent(in) :: is_analog    ! Is this an analog or TL event?
    real(8), intent(in) :: Ein          ! Incoming energy
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in) :: nuscatt         ! Is this for nuscatter?

    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: i_score   ! index of score dimension of results
    integer :: l         ! legendre moment index
    real(8) :: norm      ! Interpolation constant multiplied by sigS (if TL)
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    real(8) :: sigs_el   ! Elastic x/s
    real(8) :: sigs_inel ! Inelastic x/s
    logical :: nuscatt_flag

    if (present(nuscatt)) then
      nuscatt_flag = nuscatt
    else
      nuscatt_flag = .false.
    end if

    ! First we need to calculate the x/s to use when creating our distribution.
    call calc_scatter_xs(i_nuclide, sigs_el, sigs_inel)

    ! Now combine the elastic and inelastic distributions to one set,
    ! which will be in ndpp_outgoing(thread_id,:,:)
    call generate_ndpp_distrib_pn(this, nuscatt_flag, gin, t_order, Ein, &
                                  sigs_el, sigs_inel, norm, gmin, gmax)

    ! Apply mult to the normalization constant, norm
    norm = norm * mult
    ! Now apply sigS if we are in tracklength mode
    if (.not. is_analog) then
      norm = norm * (micro_xs(i_nuclide) % total - &
           micro_xs(i_nuclide) % absorption)
    end if

    ! Add the combined distribution to our tally
    do g = gmin, gmax
      g_filter = filter_index + g - 1
      do l = 1, t_order + 1
        i_score = score_index + l - 1
!$omp atomic
        results(i_score, g_filter) % value = &
             results(i_score, g_filter) % value + &
             ndpp_outgoing(thread_id, l, g) * norm
      end do
    end do
  end subroutine ndpp_tally_scatt_pn

!===============================================================================
! NDPP_TALLY_NDPP_SCATT_YN determines the scattering moments which were
! previously calculated with a pre-processor such as NDPP;
! this can be used for analog and tracklength estimators;
! this method applies to ndpp-scatter-yn tally types (including nu-scatter)
! which incorporate the angular flux moments.
!===============================================================================

  subroutine ndpp_tally_scatt_yn(this, i_nuclide, gin, score_index, &
                                 filter_index, t_order, mult, is_analog, Ein, &
                                 uvw, results, nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: i_nuclide    ! index into nuclides array
    integer, intent(in) :: gin          ! Incoming group index
    integer, intent(in) :: score_index  ! dim=1 starting index in results
    integer, intent(in) :: filter_index ! dim=2 starting index (Ein filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    logical, intent(in) :: is_analog    ! Is this an analog or TL event?
    real(8), intent(in) :: Ein          ! Incoming energy
    real(8), intent(in) :: uvw(3)       ! direction coordinates
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in) :: nuscatt         ! Is this for nuscatter?

    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: i_score   ! index of score dimension of results
    integer :: l         ! legendre moment index
    real(8) :: norm      ! Interpolation constant multiplied by sigS (if TL)
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    integer :: num_lm    ! Number of m for this l
    real(8) :: sigs_el   ! Elastic x/s
    real(8) :: sigs_inel ! Inelastic x/s
    logical :: nuscatt_flag

    if (present(nuscatt)) then
      nuscatt_flag = nuscatt
    else
      nuscatt_flag = .false.
    end if

    ! First we need to calculate the x/s to use when creating our distribution.
    call calc_scatter_xs(i_nuclide, sigs_el, sigs_inel)

    ! Now combine the elastic and inelastic distributions to one set,
    ! which will be in ndpp_outgoing(thread_id,:,:)
    call generate_ndpp_distrib_pn(this, nuscatt_flag, gin, t_order, Ein, &
                                  sigs_el, sigs_inel, norm, gmin, gmax)

    ! Apply mult to the n ormalization constant, norm
    norm = norm * mult
    ! Now apply sigS if we are in tracklength mode
    if (.not. is_analog) then
      norm = norm * (micro_xs(i_nuclide) % total - &
           micro_xs(i_nuclide) % absorption)
    end if

    ! Add the combined distribution to our tally for each order
    do g = gmin, gmax
      g_filter = filter_index + g - 1
      i_score = score_index
      do l = 0, t_order
        num_lm = 2 * l + 1
!$omp critical (ndpp_tally_scatt_yn)
        results(i_score: i_score + num_lm - 1, g_filter) % value = &
             results(i_score: i_score + num_lm - 1, g_filter) % value + &
             ndpp_outgoing(thread_id, l + 1, g) * norm * calc_rn(l, uvw)
!$omp end critical (ndpp_tally_scatt_yn)

        i_score = i_score + num_lm
      end do
    end do
  end subroutine ndpp_tally_scatt_yn

!===============================================================================
! NDPP_TALLY_NDPP_MAT_SCATT_N does the same as NDPP_TALLY_NDPP_SCATT_N, but
! uses the material-wise data instead of nuclidic data.
!===============================================================================

  subroutine ndpp_tally_mat_scatt_n(this, gin, score_index, filter_index, &
                                    t_order, mult, Ein, results, &
                                    nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: gin          ! Incoming group
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    real(8), intent(in) :: Ein          ! Incoming energy
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in) :: nuscatt         ! Is this for nuscatter?

    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: l         ! tally order index to score
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    logical :: nuscatt_flag

    if (present(nuscatt)) then
      nuscatt_flag = nuscatt
    else
      nuscatt_flag = .false.
    end if

    l = t_order + 1

    call generate_ndpp_mat_distrib_n(this, nuscatt_flag, gin, l, Ein, mult, &
                                     gmin, gmax)

    ! Add the combined distribution to our tally
    do g = gmin, gmax
      g_filter = filter_index + g - 1
!$omp atomic
      results(score_index, g_filter) % value = &
        results(score_index, g_filter) % value + &
        ndpp_outgoing(thread_id, l, g)
    end do
  end subroutine ndpp_tally_mat_scatt_n

!===============================================================================
! NDPP_TALLY_NDPP_MAT_SCATT_PN does the same as NDPP_TALLY_NDPP_SCATT_PN, but
! uses the material-wise data instead of nuclidic data.
!===============================================================================

  subroutine ndpp_tally_mat_scatt_pn(this, gin, score_index, filter_index, &
                                     t_order, mult, Ein, results, &
                                     nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: gin          ! Incoming group
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    real(8), intent(in) :: Ein          ! Incoming energy
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in) :: nuscatt         ! Is this for nuscatter?

    integer :: i_score   ! index of score dimension of results
    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: l         ! tally order index to score
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    logical :: nuscatt_flag

    if (present(nuscatt)) then
      nuscatt_flag = nuscatt
    else
      nuscatt_flag = .false.
    end if

    l = t_order + 1

    call generate_ndpp_mat_distrib_pn(this, nuscatt_flag, gin, l, Ein, mult, &
                                      gmin, gmax)

    ! Add the combined distribution to our tally
    do g = gmin, gmax
      g_filter = filter_index + g - 1
      do l = 1, t_order + 1
        i_score = score_index + l - 1
!$omp atomic
        results(i_score, g_filter) % value = &
          results(i_score, g_filter) % value + ndpp_outgoing(thread_id, l, g)
      end do
    end do
  end subroutine ndpp_tally_mat_scatt_pn

!===============================================================================
! NDPP_TALLY_NDPP_MAT_SCATT_YN does the same as NDPP_TALLY_NDPP_SCATT_YN, but
! uses the material-wise data instead of nuclidic data.
!===============================================================================

  subroutine ndpp_tally_mat_scatt_yn(this, gin, score_index, filter_index, &
                                     t_order, mult, Ein, uvw, results, &
                                     nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: gin          ! Incoming group
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    real(8), intent(in) :: Ein          ! Incoming energy
    real(8), intent(in) :: uvw(3)       ! direction coordinates
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in)    :: nuscatt      ! Is this for nuscatter?

    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: l         ! tally order index to score
    integer :: num_lm    ! Number of m for this l
    integer :: i_score   ! index of score dimension of results
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    logical :: nuscatt_flag

    if (present(nuscatt)) then
      nuscatt_flag = nuscatt
    else
      nuscatt_flag = .false.
    end if

    l = t_order + 1

    call generate_ndpp_mat_distrib_pn(this, nuscatt_flag, gin, l, Ein, mult, &
                                      gmin, gmax)

    ! Add the combined distribution to our tally for each order
    do g = gmin, gmax
      g_filter = filter_index + g - 1
      i_score = score_index
      do l = 0, t_order
        num_lm = 2 * l + 1
!$omp critical (ndpp_tally_mat_scatt_yn)
        results(i_score: i_score + num_lm - 1, g_filter) % value = &
          results(i_score: i_score + num_lm - 1, g_filter) % value + &
          ndpp_outgoing(thread_id, l + 1, g) * calc_rn(l, uvw)
!$omp end critical (ndpp_tally_mat_scatt_yn)

        i_score = i_score + num_lm
      end do
    end do
  end subroutine ndpp_tally_mat_scatt_yn

!===============================================================================
! TALLY_NDPP_CHI determines the fission spectra which were
! previously calculated with a pre-processor such as NDPP;
! this can be used for analog and tracklength estimators;
! this method applies to ndpp-scatter-chi tally types
!===============================================================================

  subroutine ndpp_tally_chi(this, i_nuclide, score_index, filter_index, mult, &
                            is_analog, Ein, score_type, results)

    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: i_nuclide    ! index into nuclides array
    integer, intent(in) :: score_index  ! dim=1 starting index in results
    integer, intent(in) :: filter_index ! dim=2 starting index (Ein filter)
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    logical, intent(in) :: is_analog    ! Is this an analog or TL event?
    real(8), intent(in) :: Ein          ! Incoming energy
    integer, intent(in) :: score_type   ! Type of Chi score we are using
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage

    integer :: g                         ! outgoing energy group index
    integer :: g_filter                  ! outgoing energy group index
    integer :: i_grid                    ! index on nuclide energy grid
    real(8) :: f                         ! interp factor on nuclide energy grid
    real(8) :: one_f                     ! (ONE - f)

    ! Find the grid index and interpolant of ndpp scattering data
    if (Ein <= this % chi_Ein(1)) then
      i_grid = 1
      f = ZERO
    else if (Ein >= this % chi_Ein(size(this % chi_Ein))) then
      ! Should never happen as max(ndpp_Ein) is above filter range
      return
    else
      i_grid = binary_search(this % chi_Ein, size(this % chi_Ein), Ein)
      f = (Ein - this % chi_Ein(i_grid)) / &
           (this % chi_Ein(i_grid + 1) - this % chi_Ein(i_grid))
    end if

    ! Calculate 1-f, apply mult, and weight by nu-fission for TL
    one_f = (ONE - f) * mult
    f = f * mult
    ! Weight only by nu for analog since the collision estimator process already
    ! is effectively sampling the fission xs
    if (.not. is_analog) then
      f = f * micro_xs(i_nuclide) % nu_fission
      one_f = one_f * micro_xs(i_nuclide) % nu_fission
    end if

    ! Add the contribution from NDPP data (with interpolation)
    if (score_type == SCORE_NDPP_CHI) then
      do g = 1, ubound(this % chi, dim=1)
        g_filter = filter_index + g - 1
!$omp atomic
        results(score_index, g_filter) % value = &
             results(score_index, g_filter) % value + &
             this % chi(g, i_grid) * one_f + &
             this % chi(g, i_grid + 1) * f
      end do
    else if (score_type == SCORE_NDPP_CHI_P) then
      do g = 1, ubound(this % chi_p, dim=1)
        g_filter = filter_index + g - 1
!$omp atomic
        results(score_index, g_filter) % value = &
             results(score_index, g_filter) % value + &
             this % chi_p(g, i_grid) * one_f + &
             this % chi_p(g, i_grid + 1) * f
      end do
    else if (score_type == SCORE_NDPP_CHI_D) then
      call fatal_error("OpenMC does not yet support Delayed Chi Tallying!")
    end if

  end subroutine ndpp_tally_chi

!===============================================================================
! TALLY_NDPP_MAT_CHI determines the fission spectra which were
! previously calculated with a pre-processor such as NDPP;
! this can be used for analog and tracklength estimators;
! this method applies to ndpp-scatter-chi tally types.
! This routine uses the macroscopic data
!===============================================================================

  subroutine ndpp_tally_mat_chi(this, score_index, filter_index, mult, &
                                Ein, score_type, results)

    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    real(8), intent(in) :: mult         ! wgt or wgt * flux
    real(8), intent(in) :: Ein          ! Incoming energy
    integer, intent(in) :: score_type   ! Type of Chi score we are using
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage

    integer :: g                         ! outgoing energy group index
    integer :: g_filter                  ! outgoing energy group index
    integer :: i_grid                    ! index on nuclide energy grid
    real(8) :: f                         ! interp factor on nuclide energy grid
    real(8) :: one_f                     ! (ONE - f)
    ! Find the grid index and interpolant of ndpp scattering data
    if (Ein <= this % chi_Ein(1)) then
      i_grid = 1
      f = ZERO
    else if (Ein >= this % chi_Ein(size(this % chi_Ein))) then
      ! Should never happen as max(ndpp_Ein) is above filter range
      return
    else
      i_grid = binary_search(this % chi_Ein, size(this % chi_Ein), Ein)
      f = (Ein - this % chi_Ein(i_grid)) / &
           (this % chi_Ein(i_grid + 1) - this % chi_Ein(i_grid))
    end if

    ! Calculate 1-f, apply mult, and weight by nu-fission for TL
    one_f = (ONE - f) * mult
    f = f * mult

    ! Add the contribution from NDPP data (with interpolation)
    if (score_type == SCORE_NDPP_CHI) then
      do g = 1, ubound(this % chi, dim=1)
        g_filter = filter_index + g - 1
!$omp atomic
        results(score_index, g_filter) % value = &
                results(score_index, g_filter) % value + &
                this % chi(g, i_grid) * one_f + &
                this % chi(g, i_grid + 1) * f
      end do
    else if (score_type == SCORE_NDPP_CHI_P) then
      do g = 1, ubound(this % chi_p, dim=1)
        g_filter = filter_index + g - 1
!$omp atomic
        results(score_index, g_filter) % value = &
                results(score_index, g_filter) % value + &
                this % chi_p(g, i_grid) * one_f + &
                this % chi_p(g, i_grid + 1) * f
      end do
    else if (score_type == SCORE_NDPP_CHI_D) then
      call fatal_error("OpenMC does not yet support Delayed Chi Tallying!")
    end if

  end subroutine ndpp_tally_mat_chi

!===============================================================================
! HELPER SUBROUTINES
!===============================================================================

!===============================================================================
! CALC_SCATTER_XS Find the elastic and total inelastic cross-sections at the
! given energy Ein for the nuclide denoted by i_nuclide.
!===============================================================================

  subroutine calc_scatter_xs(i_nuclide, sigs_el, sigs_inel)
    integer, intent(in)  :: i_nuclide ! index into nuclides array
    real(8), intent(out) :: sigs_el   ! Elastic x/s
    real(8), intent(out) :: sigs_inel ! Inelastic x/s

    if (micro_xs(i_nuclide) % use_ptable) then
      ! We have to get the non-URR elastic x/s which is the average value
      sigs_el = (ONE - micro_xs(i_nuclide) % interp_factor) * &
           nuclides(i_nuclide) % elastic(micro_xs(i_nuclide) % index_grid) &
           + micro_xs(i_nuclide) % interp_factor * &
           nuclides(i_nuclide) % elastic(micro_xs(i_nuclide) % index_grid + 1)
      ! First get the total scattering x/s
      sigs_inel = (ONE - micro_xs(i_nuclide) % interp_factor) * &
           (nuclides(i_nuclide) % total(micro_xs(i_nuclide) % index_grid) - &
            nuclides(i_nuclide) % absorption(micro_xs(i_nuclide) % index_grid)) + &
           (micro_xs(i_nuclide) % interp_factor) * &
           (nuclides(i_nuclide) % total(micro_xs(i_nuclide) % index_grid + 1) - &
            nuclides(i_nuclide) % absorption(micro_xs(i_nuclide) % index_grid + 1))
      ! Now take away elastic to get the total inelastic
      sigs_inel = sigs_inel - sigs_el
    else
      sigs_el   = micro_xs(i_nuclide) % elastic
      sigs_inel = micro_xs(i_nuclide) % total - &
           micro_xs(i_nuclide) % absorption - &
           sigs_el
    end if

  end subroutine calc_scatter_xs


!===============================================================================
! FIND_NDPP_INDICES determines the group boundaries of relevant data in both
! the elastic and inelastic NDPP data sets (as passed to it by the el_* and
! inel_*) data.  Since the data is readily available, it also finds the
! interpolation factors el_f and inel_f.
!===============================================================================

  subroutine find_ndpp_indices(this, gin, Ein, el_gmin, el_gmax, &
                               inel, inel_gmin, inel_gmax, gmin, gmax, &
                               el_igrid, inel_igrid, el_f, inel_f)
    type(Ndpp), intent(in) :: this       ! Ndpp data to use
    integer, intent(in)    :: gin        ! Incoming group index
    real(8), intent(in)    :: Ein        ! Incoming energy
    integer, intent(out)   :: el_gmin    ! Elastic min outgoing group
    integer, intent(out)   :: el_gmax    ! Elastic max outgoing group
    type(GroupTransfer), pointer, intent(in) :: inel(:) ! Inelastic data to use
    integer, intent(out)   :: inel_gmin  ! Inelastic min outgoing group
    integer, intent(out)   :: inel_gmax  ! Inelastic max outgoing group
    integer, intent(out)   :: gmin       ! Min out group for both el and inel
    integer, intent(out)   :: gmax       ! Max out group for both el and inel
    real(8), intent(out)   :: el_f       ! Elastic interpolant
    real(8), intent(out)   :: inel_f     ! Inelastic interpolant
    integer, intent(out)   :: el_igrid   ! Elastic data location
    integer, intent(out)   :: inel_igrid ! Inelastic data location

    integer :: srch_lo, srch_hi

    inel_gmin = huge(0)
    inel_gmax = 0

    ! Create distribution for elastic scattering
    ! First perform the binary search to find where our Ein point is
    srch_lo = this % el_Ein_srch(gin)
    srch_hi = this % el_Ein_srch(gin + 1)
    ! Find the grid index and interpolant of ndpp scattering data
    if (Ein <= this % el_Ein(1)) then
      el_igrid = 1
      el_f = ZERO
    else if (Ein >= this % el_Ein(size(this % el_Ein))) then
      el_igrid = size(this % el_Ein) - 1
      el_f = ONE
    else
      el_igrid = binary_search(this % el_Ein(srch_lo: srch_hi), &
                               srch_hi - srch_lo + 1, Ein) + srch_lo - 1
      el_f = log(Ein / this % el_Ein(el_igrid)) / &
           log(this % el_Ein(el_igrid + 1) / this % el_Ein(el_igrid))
    end if

    ! Now find our gmin and gmax terms
    el_gmin = min(lbound(this % el(el_igrid) % outgoing, dim=2), &
                  lbound(this % el(el_igrid + 1) % outgoing, dim=2))
    el_gmax = max(ubound(this % el(el_igrid) % outgoing, dim=2), &
                  ubound(this % el(el_igrid + 1) % outgoing, dim=2))

    ! Now do the same for inelastic, if it is necessary (i.e., if not s(a,b))
    ! We can tell if we are s(a,b) because then the inel* pointers will be null
    if (associated(inel)) then
      if (Ein <= this % inel_Ein(1)) then
        ! Then our point is below the threshold: break this conditional
        ! without changing inel_gmin and inel_gmax
        gmin = el_gmin
        gmax = el_gmax
        if (gmin == huge(0)) then
          gmin = 0
          gmax = -1
        end if
      else
        ! Perform same steps as above, but with inelastic.
        ! Also, we will get normalization constants from the NDPP data itself.
        ! First perform the binary search to find where our incoming E point is
        srch_lo = this % inel_Ein_srch(gin)
        srch_hi = this % inel_Ein_srch(gin + 1)
        ! Find the grid index and interpolant of ndpp scattering data
        if (Ein >= this % inel_Ein(size(this % inel_Ein))) then
          inel_igrid = size(this % inel_Ein) - 1
          inel_f = ONE
        else
          inel_igrid = binary_search(this % inel_Ein(srch_lo: srch_hi), &
                                     srch_hi - srch_lo + 1, Ein) + srch_lo - 1
          inel_f = log(Ein / this % inel_Ein(inel_igrid)) / &
               log(this % inel_Ein(inel_igrid + 1) / this % inel_Ein(inel_igrid))
        end if

        ! Now find our gmin and gmax terms
        if ((allocated(inel(inel_igrid) % outgoing)) .and. &
            (allocated(inel(inel_igrid + 1) % outgoing))) then
          inel_gmin = min(lbound(inel(inel_igrid) % outgoing, dim=2), &
                          lbound(inel(inel_igrid + 1) % outgoing, dim=2))
          inel_gmax = max(ubound(inel(inel_igrid) % outgoing, dim=2), &
                          ubound(inel(inel_igrid + 1) % outgoing, dim=2))
        else if (allocated(inel(inel_igrid) % outgoing)) then
          inel_gmin = lbound(inel(inel_igrid) % outgoing, dim=2)
          inel_gmax = ubound(inel(inel_igrid) % outgoing, dim=2)
        else if (allocated(inel(inel_igrid + 1) % outgoing)) then
          inel_gmin = lbound(inel(inel_igrid+1) % outgoing, dim=2)
          inel_gmax = ubound(inel(inel_igrid+1) % outgoing, dim=2)
        end if

        ! Set our group boundaries
        gmin = min(el_gmin, inel_gmin)
        gmax = max(el_gmax, inel_gmax)
      end if
    else
      ! Set our other outgoing data
      gmin = el_gmin
      gmax = el_gmax
    end if

    ! Fix up gmin and gmax if need be
    if (gmin == huge(0)) then
      gmin = 0
      gmax = -1
    end if

  end subroutine find_ndpp_indices

!===============================================================================
! GENERATE_NDPP_DISTRIB_N combines the elastic and inelastic portions of the
! NDPP scattering data such that a single number can be readily tallied.
! This includes performing all the interpolation necessary.  The *_N version of
! this function provides this capability for score-ndpp-*scatter-n tallies only.
!===============================================================================

  subroutine generate_ndpp_distrib_n(this, nuscatt, gin, l, Ein, sigs_el, &
                                     sigs_inel, norm, gmin, gmax)
    type(Ndpp), intent(in) :: this      ! Ndpp data to use
    logical, intent(in)    :: nuscatt   ! Is this for nuscatter?
    integer, intent(in)    :: gin       ! Incoming group index
    integer, intent(in)    :: l         ! Legendre order to score up to
    real(8), intent(in)    :: Ein       ! Incoming energy
    real(8), intent(in)    :: sigs_el   ! Elastic x/s
    real(8), intent(in)    :: sigs_inel ! Inelastic x/s
    real(8), intent(inout) :: norm      ! Total normalization
    integer, intent(inout) :: gmin      ! Minimum group transfer of ndpp data
    integer, intent(inout) :: gmax      ! Maximum group transfer of ndpp data

    integer :: el_igrid, inel_igrid
    integer :: el_gmin, el_gmax, inel_gmin, inel_gmax, g
    real(8) :: el_f, el_one_f, inel_f, inel_one_f
    type(GroupTransfer), pointer :: inel(:)

    ! Now set our inelastic data to be inelastic or nuinel, depending on type
    ! requested
    if (nuscatt) then
      inel => this % nuinel
    else
      inel => this % inel
    end if

    ! Find where our data is
    call find_ndpp_indices(this, gin, Ein, el_gmin, el_gmax, &
                           inel, inel_gmin, inel_gmax, gmin, gmax, &
                           el_igrid, inel_igrid, el_f, inel_f)

    ! Create our 1-interpolants based on the newly found *el_f values
    el_one_f   = ONE - el_f
    inel_one_f = ONE - inel_f
    norm = ONE / (sigs_el + sigs_inel)

    ! Set up our distribution storage so we can add the components up
    ndpp_outgoing(thread_id, l, gmin: gmax) = ZERO

    ! Now we can interpolate on the elastic data and put it in ndpp_outgoing
    ! Do lower point
    if (allocated(this % el(el_igrid) % outgoing)) then
      el_one_f = el_one_f * sigs_el
      do g = lbound(this % el(el_igrid) % outgoing, dim=2), &
             ubound(this % el(el_igrid) % outgoing, dim=2)
        ndpp_outgoing(thread_id, l, g) = el_one_f * &
             this % el(el_igrid) % outgoing(l, g)
      end do
    end if
    ! Do upper point
    if (allocated(this % el(el_igrid + 1) % outgoing)) then
      el_f = el_f * sigs_el
      do g = lbound(this % el(el_igrid + 1) % outgoing, dim=2), &
             ubound(this % el(el_igrid + 1) % outgoing, dim=2)
        ndpp_outgoing(thread_id, l, g) = &
             ndpp_outgoing(thread_id, l, g) + &
             el_f * this % el(el_igrid + 1) % outgoing(l, g)
      end do
    end if

    ! And do the same for inelastic, if necessary
    if (inel_gmin /= huge(0)) then
      ! Do lower point
      if (allocated(inel(inel_igrid) % outgoing)) then
        do g = lbound(inel(inel_igrid) % outgoing, dim=2), &
               ubound(inel(inel_igrid) % outgoing, dim=2)
          ndpp_outgoing(thread_id, l, g) = ndpp_outgoing(thread_id, l, g) + &
               inel(inel_igrid) % outgoing(l, g) * inel_one_f
        end do
      end if
      ! Do upper point
      if (allocated(inel(inel_igrid + 1) % outgoing)) then
        do g = lbound(inel(inel_igrid + 1) % outgoing, dim=2), &
               ubound(inel(inel_igrid + 1) % outgoing, dim=2)
          ndpp_outgoing(thread_id, l, g) = ndpp_outgoing(thread_id, l, g) + &
               inel(inel_igrid + 1) % outgoing(l, g) * inel_f
        end do
      end if
    end if

  end subroutine generate_ndpp_distrib_n

!===============================================================================
! GENERATE_NDPP_DISTRIB_PN combines the elastic and inelastic portions of the
! NDPP scattering data such that a single number can be readily tallied.
! This includes performing all the interpolation necessary.  The *_PN version of
! this function provides this capability for score-ndpp-*scatter-pn tallies only.
!===============================================================================

  subroutine generate_ndpp_distrib_pn(this, nuscatt, gin, l, Ein, sigs_el, &
                                      sigs_inel, norm, gmin, gmax)
    type(Ndpp), intent(in) :: this      ! Ndpp data to use
    logical, intent(in)    :: nuscatt    ! Is this for nuscatter?
    integer, intent(in)    :: gin       ! Incoming group index
    integer, intent(in)    :: l         ! Legendre order to score up to
    real(8), intent(in)    :: Ein       ! Incoming energy
    real(8), intent(in)    :: sigs_el   ! Elastic x/s
    real(8), intent(in)    :: sigs_inel ! Inelastic x/s
    real(8), intent(inout) :: norm      ! Total normalization
    integer, intent(inout) :: gmin      ! Minimum group transfer in ndpp data
    integer, intent(inout) :: gmax      ! Maximum group transfer in ndpp data

    integer :: el_igrid, inel_igrid
    integer :: el_gmin, el_gmax, inel_gmin, inel_gmax, g
    real(8) :: el_f, el_one_f, inel_f, inel_one_f
    type(GroupTransfer), pointer :: inel(:)

    ! Now set our inelastic data to be inelastic or nuinel, depending on type
    ! requested
    if (nuscatt) then
      inel => this % nuinel
    else
      inel => this % inel
    end if

    ! Find where our data is
    call find_ndpp_indices(this, gin, Ein, el_gmin, el_gmax, &
                           inel, inel_gmin, inel_gmax, gmin, gmax, &
                           el_igrid, inel_igrid, el_f, inel_f)

    ! Create our 1-interpolants based on the newly found *el_f values
    el_one_f   = ONE - el_f
    inel_one_f = ONE - inel_f
    norm = ONE / (sigs_el + sigs_inel)

    ! Set up our distribution storage so we can add the components up
    ndpp_outgoing(thread_id, 1: l + 1, gmin: gmax) = ZERO

    ! Now we can interpolate on the elastic data and put it in ndpp_outgoing
    ! Do lower point
    if (allocated(this % el(el_igrid) % outgoing)) then
      el_one_f = el_one_f * sigs_el
      do g = lbound(this % el(el_igrid) % outgoing, dim=2), &
             ubound(this % el(el_igrid) % outgoing, dim=2)
        ndpp_outgoing(thread_id, 1: l + 1, g) = el_one_f * &
             this % el(el_igrid) % outgoing(1: l + 1, g)
      end do
    end if
    ! Do upper point
    if (allocated(this % el(el_igrid + 1) % outgoing)) then
      el_f = el_f * sigs_el
      do g = lbound(this % el(el_igrid + 1) % outgoing, dim=2), &
             ubound(this % el(el_igrid + 1) % outgoing, dim=2)
        ndpp_outgoing(thread_id, 1: l + 1, g) = &
             ndpp_outgoing(thread_id, 1: l + 1, g) + &
             el_f * this % el(el_igrid + 1) % outgoing(1: l + 1, g)
      end do
    end if

    ! And do the same for inelastic, if necessary
    if (inel_gmin /= huge(0)) then
      ! Do lower point
      if (allocated(inel(inel_igrid) % outgoing)) then
        do g = lbound(inel(inel_igrid) % outgoing, dim=2), &
               ubound(inel(inel_igrid) % outgoing, dim=2)
          ndpp_outgoing(thread_id, 1: l + 1, g) = &
               ndpp_outgoing(thread_id, 1: l + 1, g) + &
               inel(inel_igrid) % outgoing(1: l + 1, g) * inel_one_f
        end do
      end if
      ! Do upper point
      if (allocated(inel(inel_igrid + 1) % outgoing)) then
        do g = lbound(inel(inel_igrid + 1) % outgoing, dim=2), &
               ubound(inel(inel_igrid + 1) % outgoing, dim=2)
          ndpp_outgoing(thread_id, 1: l + 1, g) = &
            ndpp_outgoing(thread_id, 1: l + 1, g) + &
            inel(inel_igrid + 1) % outgoing(1: l + 1, g) * inel_f
        end do
      end if
    end if

  end subroutine generate_ndpp_distrib_pn

!===============================================================================
! GENERATE_NDPP_MAT_* do the same as their non-MAT alternatives, but do it for
! the simplified case of a material-specific NDPP data object.
!===============================================================================

  subroutine generate_ndpp_mat_distrib_n(this, nuscatt, gin, l, Ein, norm, &
                                         gmin, gmax)
    type(Ndpp), intent(in) :: this      ! Ndpp data to use
    logical, intent(in)    :: nuscatt   ! Is this for nuscatter?
    integer, intent(in)    :: gin       ! Incoming group index
    integer, intent(in)    :: l         ! Legendre order to score up to
    real(8), intent(in)    :: Ein       ! Incoming energy
    real(8), intent(in) :: norm      ! Total normalization
    integer, intent(inout) :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer, intent(inout) :: gmax      ! Maximum group transfer in ndpp_outgoing

    integer :: srch_lo, srch_hi, g
    integer :: igrid
    real(8) :: f, one_f
    type(GroupTransfer), pointer :: inel(:)

    if (nuscatt) then
      inel => this % nuinel
    else
      inel => this % inel
    end if

    ! Find the location in the energy array
    srch_lo = this % inel_Ein_srch(gin)
    srch_hi = this % inel_Ein_srch(gin + 1)
    ! Find the grid index and interpolant of ndpp scattering data
    if (Ein >= this % inel_Ein(size(this % inel_Ein))) then
      igrid = size(this % inel_Ein) - 1
      f = ONE
    else
      igrid = binary_search(this % inel_Ein(srch_lo: srch_hi), &
                            srch_hi - srch_lo + 1, Ein) + srch_lo - 1
      f = log(Ein / this % inel_Ein(igrid)) / &
          log(this % inel_Ein(igrid + 1) / this % inel_Ein(igrid))
    end if

    one_f = (ONE - f) * norm
    f = f * norm

    ! Now find our gmin and gmax terms
    if ((allocated(inel(igrid) % outgoing)) .and. &
        (allocated(inel(igrid + 1) % outgoing))) then
      gmin = min(lbound(inel(igrid) % outgoing, dim=2), &
                 lbound(inel(igrid + 1) % outgoing, dim=2))
      gmax = max(ubound(inel(igrid) % outgoing, dim=2), &
                 ubound(inel(igrid + 1) % outgoing, dim=2))
    else if (allocated(inel(igrid) % outgoing)) then
      gmin = lbound(inel(igrid) % outgoing, dim=2)
      gmax = ubound(inel(igrid) % outgoing, dim=2)
    else if (allocated(inel(igrid + 1) % outgoing)) then
      gmin = lbound(inel(igrid + 1) % outgoing, dim=2)
      gmax = ubound(inel(igrid + 1) % outgoing, dim=2)
    end if

    ! Set up our distribution storage so we can add the components up
    ndpp_outgoing(thread_id, l, gmin: gmax) = ZERO

    ! Do lower point
    if (allocated(inel(igrid) % outgoing)) then
      do g = lbound(inel(igrid) % outgoing, dim=2), &
             ubound(inel(igrid) % outgoing, dim=2)
        ndpp_outgoing(thread_id, l, g) = ndpp_outgoing(thread_id, l, g) + &
          inel(igrid) % outgoing(l, g) * one_f
      end do
    end if
    ! Do upper point
    if (allocated(inel(igrid + 1) % outgoing)) then
      do g = lbound(inel(igrid + 1) % outgoing, dim=2), &
             ubound(inel(igrid + 1) % outgoing, dim=2)
        ndpp_outgoing(thread_id, l, g) = ndpp_outgoing(thread_id, l, g) + &
          inel(igrid + 1) % outgoing(l, g) * f
      end do
    end if

  end subroutine generate_ndpp_mat_distrib_n


  subroutine generate_ndpp_mat_distrib_pn(this, nuscatt, gin, l, Ein, norm, &
                                          gmin, gmax)
    type(Ndpp), intent(in) :: this      ! Ndpp data to use
    logical, intent(in)    :: nuscatt   ! Is this for nuscatter?
    integer, intent(in)    :: gin       ! Incoming group index
    integer, intent(in)    :: l         ! Legendre order to score up to
    real(8), intent(in)    :: Ein       ! Incoming energy
    real(8), intent(in)    :: norm      ! Total normalization
    integer, intent(inout) :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer, intent(inout) :: gmax      ! Maximum group transfer in ndpp_outgoing

    integer :: srch_lo, srch_hi, g
    integer :: igrid
    real(8) :: f, one_f
    type(GroupTransfer), pointer :: inel(:)

    if (nuscatt) then
      inel => this % nuinel
    else
      inel => this % inel
    end if

    ! Find the location in the energy array
    srch_lo = this % inel_Ein_srch(gin)
    srch_hi = this % inel_Ein_srch(gin + 1)
    ! Find the grid index and interpolant of ndpp scattering data
    if (Ein >= this % inel_Ein(size(this % inel_Ein))) then
      igrid = size(this % inel_Ein) - 1
      f = ONE
    else
      igrid = binary_search(this % inel_Ein(srch_lo: srch_hi), &
                            srch_hi - srch_lo + 1, Ein) + srch_lo - 1
      f = log(Ein / this % inel_Ein(igrid)) / &
          log(this % inel_Ein(igrid + 1) / this % inel_Ein(igrid))
    end if

    one_f = (ONE - f) * norm
    f = f * norm

    ! Now find our gmin and gmax terms
    if ((allocated(inel(igrid) % outgoing)) .and. &
        (allocated(inel(igrid + 1) % outgoing))) then
      gmin = min(lbound(inel(igrid) % outgoing, dim=2), &
                 lbound(inel(igrid + 1) % outgoing, dim=2))
      gmax = max(ubound(inel(igrid) % outgoing, dim=2), &
                 ubound(inel(igrid + 1) % outgoing, dim=2))
    else if (allocated(inel(igrid) % outgoing)) then
      gmin = lbound(inel(igrid) % outgoing, dim=2)
      gmax = ubound(inel(igrid) % outgoing, dim=2)
    else if (allocated(inel(igrid + 1) % outgoing)) then
      gmin = lbound(inel(igrid+1) % outgoing, dim=2)
      gmax = ubound(inel(igrid+1) % outgoing, dim=2)
    end if

    ! Set up our distribution storage so we can add the components up
    ndpp_outgoing(thread_id, 1: l, gmin: gmax) = ZERO

    ! Do lower point
    if (allocated(inel(igrid) % outgoing)) then
      do g = lbound(inel(igrid) % outgoing, dim=2), &
             ubound(inel(igrid) % outgoing, dim=2)
        ndpp_outgoing(thread_id, 1: l, g) = &
             ndpp_outgoing(thread_id, 1: l, g) + &
             inel(igrid) % outgoing(1: l, g) * one_f
      end do
    end if
    ! Do upper point
    if (allocated(inel(igrid + 1) % outgoing)) then
      do g = lbound(inel(igrid + 1) % outgoing, dim=2), &
             ubound(inel(igrid + 1) % outgoing, dim=2)
        ndpp_outgoing(thread_id, 1: l, g) = &
             ndpp_outgoing(thread_id, 1: l, g) + &
             inel(igrid + 1) % outgoing(1: l, g) * f
      end do
    end if

  end subroutine generate_ndpp_mat_distrib_pn

!===============================================================================
! MERGE_IN_PLACE combines two arrays in to one longer array, maintaining the
! sorted order. This in_place routine will put the merged a and b back
! in to b when done
!===============================================================================

    subroutine merge_in_place(a, result)
      real(8), target, intent(in)         :: a(:)
      real(8), allocatable, intent(inout) :: result(:)

      real(8), target, allocatable :: b(:)
      real(8), allocatable :: merged(:)
      integer :: ndata1, ndata2, nab
      integer :: idata1, idata2, ires
      logical :: no_exit = .true.
      real(8), pointer :: data1(:), data2(:)

      allocate(b(size(result)))
      b = result
      deallocate(result)

      if (a(size(a)) > b(size(b))) then
        data1 => b
        data2 => a
      else
        data1 => a
        data2 => b
      end if

      ndata1 = size(data1)
      ndata2 = size(data2)
      nab = ndata1 + ndata2
      allocate(merged(nab))

      idata1 = 1
      idata2 = 1
      do ires = 1, nab
        if (idata1 <= ndata1 .and. idata2 <= ndata2) then
          if (data1(idata1) < data2(idata2)) then
            ! take data2 info, unless it is zero
            ! a zero Ein results in zero scattering, which is not a useful
            ! point to interpolate to.  MC codes will extrapolate in this case
            ! from the bottom-two points. This is more desirable than interpolating
            ! between 0 and the next highest Ein.
            ! Even more desirable, perhaps, would be interpolating between
            ! a suitably low, but non-zero Ein, and the next highest Ein
            if (data1(idata1) == ZERO) then
              merged(ires) = 1.0E-11_8
            else
              merged(ires) = data1(idata1)
            end if
            idata1 = idata1 + 1
          else if (data1(idata1) == data2(idata2)) then
            ! take data1 info, but increment both
            merged(ires) = data1(idata1)
            idata1 = idata1 + 1
            idata2 = idata2 + 1
          else
            ! take data2 info, unless it is zero
            ! a zero Ein results in zero scattering, which is not a useful
            ! point to interpolate to.  MC codes will extrapolate in this case
            ! from the bottom-two points. This is more desirable than interpolating
            ! between 0 and the next highest Ein.
            ! Even more desirable, perhaps, would be interpolating between
            ! a suitably low, but non-zero Ein, and the next highest Ein
            if (data2(idata2) == ZERO) then
              merged(ires) = 1.0E-11_8
            else
              merged(ires) = data2(idata2)
            end if
            idata2 = idata2 + 1
          end if
        else if (idata1 <= ndata1) then
          ! There are more data1 data than data2s
          ! Take an data1 and then stop building array
          merged(ires) = data1(idata1)
          idata1 = idata1 + 1
          no_exit = .false.
          exit
        else if (idata2 <= ndata2) then
          ! There are more data2s than data1 data
          merged(ires) = data2(idata2)
          idata2 = idata2 + 1
        else
          no_exit = .false.
          exit
        end if
      end do

      ! ! Clear result if it has values (as it will when it gets here)
      ! if (allocated(result)) then
      !   deallocate(result)
      ! end if

      ! Adjust ires
      if ((.not. no_exit) .or. (ires > nab)) then
        ires = ires - 1
      end if

      ! Store our results
      allocate(result(ires))
      result = merged(1: ires)
      ! Clean up
      deallocate(merged)
      deallocate(b)
    end subroutine merge_in_place

!===============================================================================
! THIN_GRID thins an y(x) and y2(x) grid at the same time to a user-specified
! interpolation tolerance.
!===============================================================================

    subroutine thin_grid(xout, yout, yout2, tokeep, tol, compression, maxerr)
      real(8), pointer, intent(inout) :: xout(:)      ! Resultant x grid
      type(GroupTransfer), pointer, intent(inout) :: yout(:)  ! Resultant y values
      type(GroupTransfer), pointer, intent(inout) :: yout2(:) ! Resultant y values
      real(8), allocatable, intent(in)    :: tokeep(:)    ! x points to keep
      real(8), intent(in)                 :: tol          ! Desired fractional error to maintain
      real(8), intent(out)                :: compression  ! Data reduction fraction
      real(8), intent(inout)              :: maxerr       ! Maximum error due to compression

      real(8), allocatable :: xin(:)       ! Incoming x grid
      type(GroupTransfer), allocatable :: yin(:)   ! Incoming y values
      type(GroupTransfer), allocatable :: yin2(:)  ! Incoming y values
      integer :: i, j, k, klo, khi
      integer :: all_ok
      real(8) :: x1, y1, x2, y2, x, y, testval
      integer :: num_keep, remove_it
      real(8) :: initial_size
      real(8) :: error
      real(8) :: x_frac

      initial_size = real(size(xout), 8)

      ! Duplicate the input for temporary work
      allocate(xin(size(xout)))
      xin = xout
      xout = ZERO

      allocate(yin(size(yout)))
      do i = 1, size(yout)
        allocate(yin(i) % outgoing(size(yout(i) % outgoing,dim = 1), &
                                   size(yout(i) % outgoing,dim = 2)))
        yin(i) % outgoing = yout(i) % outgoing
        yout(i) % outgoing = ZERO
      end do
      allocate(yin2(size(yout2)))
      do i = 1, size(yout2)
        allocate(yin2(i) % outgoing(size(yout2(i) % outgoing,dim = 1), &
                                    size(yout2(i) % outgoing,dim = 2)))
        yin2(i) % outgoing = yout2(i) % outgoing
        yout2(i) % outgoing = ZERO
      end do

      maxerr = ZERO

      ! Keep first point's data
      xout(1) = xin(1)
      yout(1) % outgoing = yin(1) % outgoing
      yout2(1) % outgoing = yin2(1) % outgoing

      ! This loop will step through each entry in x and y and check to see if
      ! all of the values in outgoing can be replaced with interpolation.
      ! If not, the value will be saved to a new array, if so, it will be
      ! skipped.

      ! Initialize data
      num_keep = 1  ! Keeping the 1st point, so we already have one
      klo = 1       ! klo is the lower point of interpolation
      khi = 3       ! khi is the upper point of interpolation
      k = 2         ! Since we are keeping the first spot, we are currently checking
                    ! the second (k=2)

      do while (khi <= size(xin))
        ! all_ok is the total number of points we need to check, and so is
        ! simply the size of outgoing at our current data point (k)
        all_ok = size(yin(k) % outgoing) + size(yin2(k) % outgoing)

        remove_it = 0
        x1 = xin(klo)
        x2 = xin(khi)
        x  = xin(k)

        x_frac = ONE / log(x2 / x1) * log(x / x1)  ! Log interp.

        ! Check to see if this x is in the tokeep list, if its not, then check
        ! it for removal. Otherwise, it stays. This is accomplished by leaving
        ! remove_it as 0, entering the else portion of if(remove_it==all_ok)
        if (.not. any(tokeep == x)) then
          ORDER_LOOP: do i = 1, size(yin(k) % outgoing, dim=1)
            GROUP_LOOP: do j = 1, size(yin(k) % outgoing, dim=2)
              ! First check yin
              y1 = yin(klo) % outgoing(i,j)
              y2 = yin(khi) % outgoing(i,j)
              y  = yin(k) % outgoing(i,j)
              testval = y1 + (y2-y1) * x_frac
              error = abs(testval - y)
              if (y /= ZERO) then
                error = error / y
              end if
              if (error <= tol) then
                remove_it = remove_it + 1
                if (error > maxerr) then
                  maxerr = abs(testval - y)
                end if
              end if
              ! And now check yin2
              y1 = yin2(klo) % outgoing(i,j)
              y2 = yin2(khi) % outgoing(i,j)
              y  = yin2(k) % outgoing(i,j)
              testval = y1 + (y2-y1) * x_frac
              error = abs(testval - y)
              if (y /= ZERO) then
                error = error / y
              end if
              if (error <= tol) then
                remove_it = remove_it + 1
                if (error > maxerr) then
                  maxerr = abs(testval - y)
                end if
              end if
            end do GROUP_LOOP
          end do ORDER_LOOP
        end if
        ! Now place the point in to the proper bin and advance iterators.
        if (remove_it == all_ok) then
          ! Then don't put it in the new grid but advance iterators
          k = k + 1
          khi = khi + 1
        else
          ! Put it in new grid and advance iterators accordingly
          num_keep = num_keep + 1
          xout(num_keep) = xin(k)
          yout(num_keep) % outgoing = yin(k) % outgoing
          yout2(num_keep) % outgoing = yin2(k) % outgoing
          klo = k
          k = k + 1
          khi = khi + 1
        end if
      end do
      ! Save the last point's data
      num_keep = num_keep + 1
      xout(num_keep) = xin(size(xin))
      yout(num_keep) % outgoing = yin(size(xin)) % outgoing
      yout2(num_keep) % outgoing = yin2(size(xin)) % outgoing

      ! Finally, xout and yout were sized to match xin and yin since we knew
      ! they would be no larger than those.  Now we must resize these arrays
      ! and copy only the useful data in. Will use xin/yin for temp arrays.
      xin = xout(1:num_keep)
      do i = 1, num_keep
        yin(i) % outgoing = yout(i) % outgoing
        yin2(i) % outgoing = yout2(i) % outgoing
      end do

      deallocate(xout)
      deallocate(yout)
      deallocate(yout2)
      allocate(xout(num_keep))
      xout = xin(1:num_keep)

      allocate(yout(num_keep))
      allocate(yout2(num_keep))
      do i = 1, num_keep
        allocate(yout(i) % outgoing(size(yin(i) % outgoing,dim = 1), &
                                    size(yin(i) % outgoing,dim = 2)))
        yout(i) % outgoing = yin(i) % outgoing

        allocate(yout2(i) % outgoing(size(yin2(i) % outgoing,dim = 1), &
                                    size(yin2(i) % outgoing,dim = 2)))
        yout2(i) % outgoing = yin2(i) % outgoing
      end do

      ! Clean up
      deallocate(xin)
      deallocate(yin)
      deallocate(yin2)

      compression = (initial_size - real(size(xout),8)) / initial_size

    end subroutine thin_grid

end module ndpp_ops
